{% extends "base.html" %}

{% block content %}
<style>
    :root {
    --primary-color: #0071e3;
    --hover-color: #0062c3;
    --background-color: #ffffff;
    --text-color: #1d1d1f;
    --secondary-text: #86868b;
    --border-color: #d2d2d7;
    --card-background: rgb(255, 255, 255);
    --card-border: rgba(210, 210, 215, 0.5);
    --card-shadow: rgba(0, 0, 0, 0.05);
    --primary-color-rgb: 0, 113, 227;
    --error-color: #dc3545;
    --error-color-rgb: 220, 53, 69;
    --warning-color-rgb: 255, 193, 7;
    --success-color-rgb: 40, 167, 69;
    /* AI分析特有的变量 */
    --sidebar-bg: #f5f5f7;
    --secondary-color: #0062c3;
    --chat-bg: #ffffff;
    --ai-message-bg: #f7f7f8;
    --user-message-bg: #ffffff;
    --copy-button-bg: #f3f4f6;
    --copy-button-hover: #e5e7eb;
    --copy-button-active: #d1d5db;
    --file-preview-bg: #f8f9fa;
    --file-border: #e2e8f0;
    --file-hover: #edf2f7;
    --pdf-color: #F40F02;
    --docx-color: #2B579A;
    --xlsx-color: #217346;
    --txt-color: #5E6977;
    --json-color: #F5A623;
    --code-color: #4285F6;
    --image-color: #8E44AD;
    --zip-color: #F9A825;
    --default-file-color: #607D8B;
    --stop-button-color: #f44336;
    --stop-button-hover: #d32f2f;
}

[data-theme="dark"] {
    --primary-color: #2997ff;
    --hover-color: #0077ed;
    --background-color: #000000;
    --text-color: #f5f5f7;
    --secondary-text: #86868b;
    --border-color: #424245;
    --card-background: rgb(40, 40, 40);
    --card-border: rgba(66, 66, 69, 0.5);
    --card-shadow: rgba(0, 0, 0, 0.2);
    --primary-color-rgb: 41, 151, 255;
    --error-color: #dc3545;
    --error-color-rgb: 220, 53, 69;
    --warning-color-rgb: 255, 193, 7;
    --success-color-rgb: 40, 167, 69;
    /* AI分析特有的变量 */
    --sidebar-bg: #1e1e2b;
    --secondary-color: #0077ed;
    --chat-bg: #1e1e2b;
    --ai-message-bg: #444654;
    --user-message-bg: #1e1e2b;
    --copy-button-bg: #374151;
    --copy-button-hover: #4b5563;
    --copy-button-active: #6b7280;
    --file-preview-bg: #2d3748;
    --file-border: #4a5568;
    --file-hover: #2d3748;
    --pdf-color: #FF5252;
    --docx-color: #4FC3F7;
    --xlsx-color: #66BB6A;
    --txt-color: #B0BEC5;
    --json-color: #FFD54F;
    --code-color: #64B5F6;
    --image-color: #CE93D8;
    --zip-color: #FFE082;
    --default-file-color: #90A4AE;
    --stop-button-color: #f44336;
    --stop-button-hover: #d32f2f;
}

    /* 暖色系 */
    [data-theme="warm"] {
        --primary-color: #e67e22;
        --hover-color: #d35400;
        --background-color: #fffaf0;
        --text-color: #442c2e;
        --secondary-text: #7a6563;
        --border-color: #e8d9c5;
        --card-background: rgb(255, 250, 240);
        --card-border: rgba(232, 217, 197, 0.5);
        --card-shadow: rgba(139, 69, 19, 0.05);
        --primary-color-rgb: 230, 126, 34;
        --error-color: #dc3545;
        --error-color-rgb: 220, 53, 69;
        --warning-color-rgb: 255, 193, 7;
        --success-color-rgb: 39, 174, 96;
        /* AI分析特有的变量 */
        --sidebar-bg: #4d2c1b;
        --secondary-color: #d35400;
        --chat-bg: #fffaf0;
        --ai-message-bg: #fff5e6;
        --user-message-bg: #fffaf0;
        --copy-button-bg: #f8e5d1;
        --copy-button-hover: #f3d7b9;
        --copy-button-active: #edc9a1;
        --file-preview-bg: #fff8f0;
        --file-border: #e8d9c5;
        --file-hover: #fff3e0;
        --pdf-color: #F40F02;
        --docx-color: #2B579A;
        --xlsx-color: #217346;
        --txt-color: #5E6977;
        --json-color: #F5A623;
        --code-color: #4285F6;
        --image-color: #8E44AD;
        --zip-color: #F9A825;
        --default-file-color: #607D8B;
        --stop-button-color: #f44336;
        --stop-button-hover: #d32f2f;
    }

    /* 冷色系 */
    [data-theme="cool"] {
        --primary-color: #3498db;
        --hover-color: #2980b9;
        --background-color: #f0f8ff;
        --text-color: #2c3e50;
        --secondary-text: #617487;
        --border-color: #d1e6f9;
        --card-background: rgb(240, 248, 255);
        --card-border: rgba(209, 230, 249, 0.5);
        --card-shadow: rgba(52, 152, 219, 0.05);
        --primary-color-rgb: 52, 152, 219;
        --error-color: #dc3545;
        --error-color-rgb: 220, 53, 69;
        --warning-color-rgb: 241, 196, 15;
        --success-color-rgb: 46, 204, 113;
        /* AI分析特有的变量 */
        --sidebar-bg: #1c3859;
        --secondary-color: #2980b9;
        --chat-bg: #f0f8ff;
        --ai-message-bg: #e3f2fd;
        --user-message-bg: #f0f8ff;
        --copy-button-bg: #d1e6f9;
        --copy-button-hover: #b3d7f9;
        --copy-button-active: #95c8f9;
        --file-preview-bg: #e6f2ff;
        --file-border: #d1e6f9;
        --file-hover: #e3f2fd;
        --pdf-color: #F40F02;
        --docx-color: #2B579A;
        --xlsx-color: #217346;
        --txt-color: #5E6977;
        --json-color: #F5A623;
        --code-color: #4285F6;
        --image-color: #8E44AD;
        --zip-color: #F9A825;
        --default-file-color: #607D8B;
        --stop-button-color: #f44336;
        --stop-button-hover: #d32f2f;
    }

    /* 自然色 */
    [data-theme="nature"] {
        --primary-color: #27ae60;
        --hover-color: #219652;
        --background-color: #f5fff5;
        --text-color: #2d4a22;
        --secondary-text: #5a8c50;
        --border-color: #d5e8d4;
        --card-background: rgb(245, 255, 245);
        --card-border: rgba(213, 232, 212, 0.5);
        --card-shadow: rgba(39, 174, 96, 0.05);
        --primary-color-rgb: 39, 174, 96;
        --error-color: #dc3545;
        --error-color-rgb: 220, 53, 69;
        --warning-color-rgb: 241, 196, 15;
        --success-color-rgb: 39, 174, 96;
        /* AI分析特有的变量 */
        --sidebar-bg: #1e5428;
        --secondary-color: #219652;
        --chat-bg: #f5fff5;
        --ai-message-bg: #e8f5e9;
        --user-message-bg: #f5fff5;
        --copy-button-bg: #d5e8d4;
        --copy-button-hover: #c1debc;
        --copy-button-active: #add4a5;
        --file-preview-bg: #f1f8e9;
        --file-border: #d5e8d4;
        --file-hover: #e8f5e9;
        --pdf-color: #F40F02;
        --docx-color: #2B579A;
        --xlsx-color: #217346;
        --txt-color: #5E6977;
        --json-color: #F5A623;
        --code-color: #4285F6;
        --image-color: #8E44AD;
        --zip-color: #F9A825;
        --default-file-color: #607D8B;
        --stop-button-color: #f44336;
        --stop-button-hover: #d32f2f;
    }

    /* 科技色 */
    [data-theme="tech"] {
        --primary-color: #00bcd4;
        --hover-color: #0097a7;
        --background-color: #fafcfd;
        --text-color: #263238;
        --secondary-text: #607d8b;
        --border-color: #cfd8dc;
        --card-background: rgb(250, 252, 253);
        --card-border: rgba(207, 216, 220, 0.5);
        --card-shadow: rgba(0, 188, 212, 0.05);
        --primary-color-rgb: 0, 188, 212;
        --error-color: #ff5722;
        --error-color-rgb: 255, 87, 34;
        --warning-color-rgb: 255, 193, 7;
        --success-color-rgb: 76, 175, 80;
        /* AI分析特有的变量 */
        --sidebar-bg: #006064;
        --secondary-color: #0097a7;
        --chat-bg: #fafcfd;
        --ai-message-bg: #e0f7fa;
        --user-message-bg: #fafcfd;
        --copy-button-bg: #cfd8dc;
        --copy-button-hover: #b0bec5;
        --copy-button-active: #90a4ae;
        --file-preview-bg: #e0f7fa;
        --file-border: #cfd8dc;
        --file-hover: #e0f7fa;
        --pdf-color: #F40F02;
        --docx-color: #2B579A;
        --xlsx-color: #217346;
        --txt-color: #5E6977;
        --json-color: #F5A623;
        --code-color: #4285F6;
        --image-color: #8E44AD;
        --zip-color: #F9A825;
        --default-file-color: #607D8B;
        --stop-button-color: #f44336;
        --stop-button-hover: #d32f2f;
    }

    /* 紫色系 */
    [data-theme="lavender"] {
        --primary-color: #bb66ca;
        --hover-color: #7b1fa2;
        --background-color: #f5eafa;
        --text-color: #4a235a;
        --secondary-text: #8e44ad;
        --border-color: #e1bee7;
        --card-background: rgb(253, 249, 255);
        --card-border: rgba(225, 190, 231, 0.5);
        --card-shadow: rgba(156, 39, 176, 0.05);
        --primary-color-rgb: 156, 39, 176;
        --error-color: #dc3545;
        --error-color-rgb: 220, 53, 69;
        --warning-color-rgb: 255, 193, 7;
        --success-color-rgb: 76, 175, 80;
        /* AI分析特有的变量 */
        --sidebar-bg: #4a148c;
        --secondary-color: #7b1fa2;
        --chat-bg: #e9d2ed;
        --ai-message-bg: #f3e5f5;
        --user-message-bg: #fdf9ff;
        --copy-button-bg: #e1bee7;
        --copy-button-hover: #ce93d8;
        --copy-button-active: #ba68c8;
        --file-preview-bg: #f3e5f5;
        --file-border: #e1bee7;
        --file-hover: #f3e5f5;
        --pdf-color: #F40F02;
        --docx-color: #2B579A;
        --xlsx-color: #217346;
        --txt-color: #5E6977;
        --json-color: #F5A623;
        --code-color: #4285F6;
        --image-color: #8E44AD;
        --zip-color: #F9A825;
        --default-file-color: #607D8B;
        --stop-button-color: #f44336;
        --stop-button-hover: #d32f2f;
    }

    /* 高对比 */
    [data-theme="contrast"] {
        --primary-color: #000000;
        --hover-color: #1d1d1f;
        --background-color: #ffffff;
        --text-color: #000000;
        --secondary-text: #424245;
        --border-color: #1d1d1f;
        --card-background: rgb(255, 255, 255);
        --card-border: rgba(0, 0, 0, 0.2);
        --card-shadow: rgba(0, 0, 0, 0.1);
        --primary-color-rgb: 0, 0, 0;
        --error-color: #dc3545;
        --error-color-rgb: 220, 53, 69;
        --warning-color-rgb: 255, 193, 7;
        --success-color-rgb: 40, 167, 69;
        /* AI分析特有的变量 */
        --sidebar-bg: #000000;
        --secondary-color: #1d1d1f;
        --chat-bg: #ffffff;
        --ai-message-bg: #f5f5f5;
        --user-message-bg: #ffffff;
        --copy-button-bg: #e6e6e6;
        --copy-button-hover: #d1d1d1;
        --copy-button-active: #bdbdbd;
        --file-preview-bg: #f5f5f5;
        --file-border: #1d1d1f;
        --file-hover: #ebebeb;
        --pdf-color: #F40F02;
        --docx-color: #2B579A;
        --xlsx-color: #217346;
        --txt-color: #5E6977;
        --json-color: #F5A623;
        --code-color: #4285F6;
        --image-color: #8E44AD;
        --zip-color: #F9A825;
        --default-file-color: #607D8B;
        --stop-button-color: #f44336;
        --stop-button-hover: #d32f2f;
    }

    body {
        margin: 0;
        padding: 0;
        font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial;
        background: var(--background-color);
        color: var(--text-color);
        line-height: 1.5;
        height: 100vh;
        overflow: hidden;
        padding-bottom: 120px !important;
        position: relative;
        box-sizing: border-box;
    }

    /* 侧边栏样式 */
    .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        width: 300px;
        background: var(--background-color);
        border-right: 1px solid var(--border-color);
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        z-index: 1000;
    }

    .sidebar.collapsed {
        width: 60px;
    }

    .sidebar-header {
        padding: 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid var(--border-color);
        transition: all 0.3s ease;
    }

    .sidebar.collapsed .sidebar-header {
        padding: 20px 0;
        justify-content: center;
    }

    .toggle-sidebar {
        background: none;
        border: none;
        color: var(--text-color);
        cursor: pointer;
        padding: 8px;
        border-radius: 50%;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .toggle-sidebar:hover {
        background: rgba(0, 0, 0, 0.1);
    }
    
    .sidebar.collapsed .toggle-sidebar svg {
        transform: rotate(180deg);
    }
    
    [data-theme="dark"] .toggle-sidebar:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    /* 对历史记录消息禁用打字机效果和走马灯效果 */
    .message.no-typewriter .message-content {
        animation: none !important;
    }
    
    /* 禁用走马灯效果的样式 */
    .message.no-carousel .message-content {
        background: none !important;
    }
    
    /* 历史记录样式优化 */
    .history-view .message {
        margin-bottom: 15px;
    }

    .history-list {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        display: none; /* 保持默认隐藏 */
    }

    .no-history {
        text-align: center;
        padding: 20px;
        color: var(--text-color);
        opacity: 0.7;
        font-size: 14px;
    }

    .history-item {
        padding: 12px 16px;
        margin-bottom: 8px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
        background: var(--background-color);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .history-item:hover {
        background: rgba(0, 113, 227, 0.1);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .history-item .content {
        flex: 1;
        min-width: 0;
        margin-right: 8px;
    }

    .history-title {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        margin-bottom: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .history-title svg {
        width: 16px;
        height: 16px;
        opacity: 0.7;
    }

    .history-date {
        font-size: 12px;
        opacity: 0.7;
    }

    .delete-btn {
        padding: 6px;
        border-radius: 6px;
        border: none;
        background: transparent;
        color: var(--text-color);
        opacity: 0;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .history-item:hover .delete-btn {
        opacity: 0.6;
    }

    .delete-btn:hover {
        opacity: 1 !important;
        background: rgba(255, 59, 48, 0.1);
        color: #ff3b30;
    }

    .main-content {
        margin-left: 300px;
        padding: 20px;
        transition: all 0.3s ease;
    }

    .main-content.expanded {
        margin-left: 60px;
    }

    .new-chat-btn {
        margin: 8px 20px;
        height: 44px;
        border-radius: 8px;
        background: var(--primary-color);
        color: white;
        border: 1px solid var(--border-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 0 12px;
        font-size: 14px;
        transition: all 0.2s;
        width: calc(100% - 40px);
    }

    .new-chat-btn:hover {
        background: var(--secondary-color);
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .new-chat-btn svg {
        width: 16px;
        height: 16px;
        stroke: white;
    }

    .chat-history {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
    }

    .chat-item {
        display: flex;
        align-items: center;
        padding: 12px;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 14px;
        color: #fff;
        opacity: 0.8;
    }

    .chat-item:hover {
        background: var(--hover-color);
        opacity: 1;
    }

    .chat-item .icon {
        font-size: 16px;
        margin-right: 12px;
    }

    .chat-item .text {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    /* 主容器样式 */
    .container {
        position: fixed;
        margin-left: 300px; /* 与侧边栏宽度相同 */
        height: 100vh;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        align-items: center; /* 水平居中内容 */
        justify-content: flex-start; /* 从顶部开始排列 */
        top: 0;
        right: 0;
        bottom: 0;
        z-index: 1;
        width: calc(100% - 240px);
        margin-right: -20px; /* 添加宽度计算 */
        overflow-x: hidden; /* 防止水平滚动 */
    }

    /* 侧边栏收缩时的容器样式 */
    .sidebar.collapsed + .container {
        margin-left: 60px; /* 与收缩后的侧边栏宽度相同 */
        width: calc(100% - 0px); /* 添加宽度计算 */
        padding-left: 10px; /* 添加左侧内边距，防止内容紧贴侧边栏 */
    }

    .chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        height: 100%;
        position: relative;
        overflow-x: hidden; /* 防止水平滚动 */
        overflow-y: auto; /* 保持垂直滚动 */
        z-index: 2;
        width: 90%; /* 稍微减小宽度确保有边距 */
        max-width: 1100px; /* 调整最大宽度 */
        padding: 0 10px; /* 减小内边距 */
        margin: 0 auto; /* 添加水平居中 */
    }

    /* 响应式布局调整 */
    @media (max-width: 1400px) {
        .chat-container {
            max-width: 1000px;
        }
    }
    
    @media (max-width: 1200px) {
        .chat-container {
            max-width: 900px;
        }
    }
    
    @media (max-width: 992px) {
        .chat-container {
            max-width: 800px;
        }
    }
    
    @media (max-width: 768px) {
        .chat-container {
            max-width: 100%;
            padding: 0 10px;
        }
    }

    /* 打字机光标效果 */
    .temp-text::after {
        content: "|";
        animation: blink 1s step-end infinite;
        color: var(--text-color);
    }

    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
    }

    .chat-messages {
        flex: 1;
        padding: 20px;
        padding-bottom: 120px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        width: 100%;
        max-width: 100%;
    }
    
    /* 聊天标题样式 */
    .chat-title {
        text-align: center;
        padding: 10px 0;
        margin-top: 10px;
        margin-left: -150px;
        position: relative;
        z-index: 10;
    }
    
    .chat-title h3 {
        font-size: 18px;
        font-weight: 600;
        margin: 0;
        padding: 0;
        color: var(--text-color);
        transition: all 0.3s ease;
    }
    
    /* 标题动画效果 */
    @keyframes titleFadeIn {
        0% { opacity: 0; transform: translateY(-20px); }
        100% { opacity: 1; transform: translateY(0); }
    }
    
    .chat-title.animate h3 {
        animation: titleFadeIn 0.8s ease forwards;
    }
    
    /* 深色模式下的标题样式 */
    [data-theme="dark"] .chat-title h3 {
        color: var(--dark-text-color);
    }
    
    /* 确保头像正确显示且不会被裁剪 */
    .message .avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        margin-right: 15px;
        flex-shrink: 0;
        overflow: hidden; /* 确保内部图片不超出边界 */
    }
    
    .message .avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
    }
    
    .message.user .avatar {
        margin-right: 0;
        margin-left: 12px;
    }
    
    /* 调整消息内容宽度 */
    .message-wrapper {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
        max-width: 100%; /* 允许内容决定宽度 */
    }

    .message {
        display: flex;
        align-items: flex-start;
        margin: 20px 0;
        animation: fadeIn 0.3s ease;
        position: relative;
        max-width: 95%; /* 略微缩小最大宽度，防止超出容器 */
        margin-left: 10px; /* 进一步减小左边距 */
        margin-right: 10px;
        width: auto; /* 改为auto，让内容决定宽度 */
    }

    .message.user {
        flex-direction: row-reverse;
        margin-right: 20px; /* 减小右侧边距 */
        margin-left: 40px; /* 增加左侧边距，为编辑按钮留出空间 */
        position: relative; /* 确保能够相对于此元素定位编辑按钮 */
        max-width: 90%; /* 确保消息框不会过宽 */
    }

    .message.ai {
        flex-direction: row;
        margin-right: 10px; /* 减小右边距 */
        margin-left: -20px; /* 增加-20px的左外边距，与原有的10px相比，整体往左移动30px */
    }

    .message .avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        margin-right: 7px;
        flex-shrink: 0;
    }


    .message.user .avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        margin-top: 20px;
        margin-left: -2px;
        margin-right: -20px;
        background: var(--primary-color);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        position: relative;
        z-index: 1003;
        flex-shrink: 0;
    }

    .message.user .message-content {
        background: linear-gradient(135deg, #5a67d8 0%, #3b7cdd 100%);
        color: white;
        margin-right: 12px; /* 减小右侧边距 */
        font-weight: 500;
        box-shadow: 0 4px 15px rgba(90, 103, 216, 0.2), 0 2px 5px rgba(90, 103, 216, 0.1);
        margin-left: 0;
        margin-top: 20px;
        margin-bottom: 20px;
        padding-right: 16px;
        word-wrap: break-word; /* 确保长文本会换行 */
        word-break: break-word; /* 适用于非英文字符 */
        overflow-wrap: break-word; /* 现代浏览器支持 */
        max-width: 100%; /* 确保内容不会超出容器 */
        border: none;
        position: relative;
        overflow: hidden;
    }

    .message.user .message-content::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, 
            rgba(255,255,255,0.07) 0%, 
            rgba(255,255,255,0.13) 50%, 
            rgba(255,255,255,0.07) 100%);
        background-size: 200% 100%;
        animation: userMessageMarquee 3s ease-in-out infinite;
        z-index: 0;
        pointer-events: none;
    }
    
    @keyframes userMessageMarquee {
        0% {
            background-position: 100% 0;
        }
        100% {
            background-position: -100% 0;
        }
    }

    .message.ai .message-content {
        background: var(--ai-message-bg);
        color: var(--text-color);
        margin-left: 4px; /* 减小左侧边距，使AI消息往左移 */
        font-weight: 400;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .message-wrapper {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
    }

    .message.ai .message-wrapper {
        align-items: flex-start;
    }

    .message.user .message-wrapper {
        align-items: flex-end;
        max-width: calc(100% - 50px); /* 为头像留出空间 */
    }

    .message-actions {
        position: absolute;
        bottom: -35px; /* 从-23px修改为-33px，向下移动10px */
        left: 63px;
        display: flex;
        gap: 8px;
        opacity: 0;
        transition: opacity 0.2s ease;
        z-index: 10;
    }

    .message.ai:hover .message-actions {
        opacity: 1 !important; /* 添加!important确保优先级 */
    }

    .action-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 6px 12px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--background-color);
        color: var(--text-color);
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s ease;
        backdrop-filter: blur(8px);
    }

    .action-btn:hover {
        background: var(--copy-button-hover);
    }

    .action-btn:active {
        background: var(--copy-button-active);
    }
    
    .speak-btn.speaking {
        color: var(--primary-color);
        background-color: rgba(16, 163, 127, 0.1);
    }
    
    .speak-btn.speaking:hover {
        color: white;
        background-color: var(--primary-color);
    }
    
    .speak-btn.speaking svg {
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0% { opacity: 0.5; }
        50% { opacity: 1; }
        100% { opacity: 0.5; }
    }

    .copy-success {
        color: #10a37f;
    }

    .action-btn svg {
        transition: transform 0.2s ease;
    }

    .action-btn:hover svg {
        transform: scale(1.1);
    }

    .regenerate-btn svg {
        animation: spin 2s linear infinite;
        animation-play-state: paused;
    }

    .regenerate-btn:hover svg {
        animation-play-state: running;
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    [data-theme="dark"] .action-btn {
        background: var(--ai-message-bg);
        border-color: var(--border-color);
    }

    [data-theme="dark"] .action-btn:hover {
        background: var(--primary-color);
        border-color: var(--primary-color);
    }

    /* 代码块样式 */
    .message-content pre {
        background: #1e1e1e;
        border-radius: 8px;
        padding: 12px 16px;
        margin: 8px 0;
        overflow-x: auto;
        position: relative;
    }

    .message-content pre code {
        font-family: 'Fira Code', 'Consolas', monospace;
        font-size: 14px;
        line-height: 1.5;
        color: #d4d4d4;
        white-space: pre;
        word-wrap: normal;
    }

    [data-theme="dark"] .message-content pre {
        background: #2d2d2d;
    }

    [data-theme="dark"] .message-content pre code {
        color: #e0e0e0;
    }

    /* 代码块滚动条样式 */
    .message-content pre::-webkit-scrollbar {
        height: 8px;
    }

    .message-content pre::-webkit-scrollbar-track {
        background: transparent;
    }

    .message-content pre::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
    }

    .message-content pre::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    /* 添加代码块和复制按钮样式 */
    .code-block-wrapper {
        position: relative;
        margin: 1em 0;
    }

    .code-block {
        position: relative;
        background: #1e1e1e;
        border-radius: 8px;
        padding: 1em;
        overflow-x: auto;
        margin: 0.5em 0;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .copy-button {
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 6px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        color: #d4d4d4;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        opacity: 0;
        backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .code-block-wrapper:hover .copy-button {
        opacity: 1;
    }

    .copy-button:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.3);
        transform: translateY(-1px);
    }

    .copy-button:active {
        transform: translateY(0);
    }

    .copy-button.copied {
        background: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
    }

    .copy-button svg {
        width: 14px;
        height: 14px;
    }

    .message-content {
        position: relative;
        flex: 1;
        padding: 12px 16px;
        border-radius: 12px;
        word-break: break-word;
        font-size: 16px;
        line-height: 1.6;
        background: var(--message-bg);
        max-width: calc(100% - 70px); /* 留出头像和边距的空间 */
        padding-right: 16px;
        margin-bottom: 0; /* 从25px减少到0，让文件紧贴消息框 */
    }

    .message.user .message-content {
        background: linear-gradient(135deg, #5a67d8 0%, #3b7cdd 100%);
        color: white;
        margin-right: 12px; /* 减小右侧边距 */
        font-weight: 500;
        box-shadow: 0 4px 15px rgba(90, 103, 216, 0.2), 0 2px 5px rgba(90, 103, 216, 0.1);
        margin-left: 0;
        padding-right: 16px;
        word-wrap: break-word; /* 确保长文本会换行 */
        word-break: break-word; /* 适用于非英文字符 */
        overflow-wrap: break-word; /* 现代浏览器支持 */
        max-width: 100%; /* 确保内容不会超出容器 */
        border: none;
        position: relative;
        overflow: hidden;
    }

    .message.user .message-content::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, 
            rgba(255,255,255,0.07) 0%, 
            rgba(255,255,255,0.13) 50%, 
            rgba(255,255,255,0.07) 100%);
        background-size: 200% 100%;
        animation: userMessageMarquee 3s ease-in-out infinite;
        z-index: 0;
        pointer-events: none;
    }
    
    @keyframes userMessageMarquee {
        0% {
            background-position: 100% 0;
        }
        100% {
            background-position: -100% 0;
        }
    }

    .message.ai .message-content {
        background: var(--ai-message-bg);
        color: var(--text-color);
        margin-left: 4px; /* 减小左侧边距，使AI消息往左移 */
        font-weight: 400;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    [data-theme="dark"] .message.ai .message-content {
        background: rgba(44, 44, 46, 0.95);
        color: rgba(255, 255, 255, 0.95);
    }

    @keyframes fadeIn {
        from { 
            opacity: 0;
            transform: translateY(10px);
        }
        to { 
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* 输入区域样式 */
    .input-container {
        position: fixed;
        bottom: 0;
        right: 0;
        background: var(--background-color);
        z-index: 1001;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding-bottom: 20px;
        transition: all 0.3s ease;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        box-sizing: border-box;
    }
    
    /* 侧边栏展开状态 */
    .sidebar:not(.collapsed) ~ .input-container {
        width: calc(100% - 300px);
        right: 0;
    }
    
    /* 侧边栏收缩状态 */
    .sidebar.collapsed ~ .input-container {
        width: calc(100% - 60px);
        right: 0;
    }

    /* 侧边栏收缩时调整聊天容器 */
    .sidebar.collapsed ~ .container .chat-container {
        width: 95%; 
        max-width: 1300px;
    }

    /* 侧边栏展开时调整聊天容器 */
    .sidebar:not(.collapsed) ~ .container .chat-container {
        width: 95%;
        max-width: 1300px;
        margin-left: auto;
        margin-right: 0;
        padding-right: 0px;
    }

    /* 侧边栏收缩时调整消息位置 */
    .sidebar.collapsed ~ .container .message.user {
        margin-right: 0px; /* 用户消息更靠右 */
    }

    .sidebar.collapsed ~ .container .message.ai {
        margin-left: -10px; /* AI消息更靠左 */
    }
    
    /* 输入区顶部分界线 */
    .input-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: var(--border-color);
        z-index: 1;
    }
    
    /* 输入框容器 */
    .input-wrapper {
        width: 85%;
        max-width: 1160px;
        margin: 15px auto 0;
        box-sizing: border-box;
        border-radius: 12px;
        border: 1px solid var(--border-color);
        background: var(--chat-bg);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        padding: 12px 15px;
        display: flex;
        align-items: center;
    }
    
    /* 输入框文本区域 */
    .input-wrapper textarea {
        flex: 1;
        min-height: 24px;
        max-height: 200px;
        padding: 0 10px;
        margin-right: 10px;
        border: none;
        background: transparent;
        resize: none;
        outline: none;
        font-size: 15px;
        line-height: 1.5;
        color: var(--text-color);
    }
    
    /* 响应式调整 */
    @media (max-width: 768px) {
        .input-wrapper {
            width: 95%;
        }
    }

    .input-tools {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .tool-button {
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        background: transparent;
        border: none;
        color: var(--text-color);
        cursor: pointer;
        transition: all 0.2s;
    }

    .tool-button:hover {
        background: rgba(0, 0, 0, 0.05);
    }

    .send-button {
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        background: var(--primary-color);
        border: none;
        color: white;
        cursor: pointer;
        transition: all 0.2s;
    }

    .send-button:hover {
        opacity: 0.9;
        transform: translateY(-1px);
    }

    .send-button:active {
        transform: translateY(-1px);
    }

    .tool-button svg, .send-button svg {
        width: 16px;
        height: 16px;
    }

    /* 聊天区域容器 */
    .chat-container {
        height: calc(100vh - 90px);
        overflow-y: auto;
        padding: 20px;
        padding-bottom: 90px;
        background: var(--background-color);
    }

    /* 滚动条样式 */
    .chat-container::-webkit-scrollbar {
        width: 8px;
    }

    .chat-container::-webkit-scrollbar-track {
        background: transparent;
    }

    .chat-container::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 4px;
    }

    .chat-container::-webkit-scrollbar-thumb:hover {
        background: var(--primary-color);
    }

    /* 加载动画优化 */
    .loading-dots {
        display: flex;
        gap: 8px;
        align-items: center;
        height: 24px;
        padding: 0 4px;
    }

    .loading-dots span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--primary-color);
        opacity: 0.6;
        animation: bounce 1.4s infinite ease-in-out both;
    }

    .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
    .loading-dots span:nth-child(2) { animation-delay: -0.16s; }

    @keyframes bounce {
        0%, 80%, 100% { 
            transform: scale(0); 
            opacity: 0.3; 
        }
        40% { 
            transform: scale(1); 
            opacity: 0.8; 
        }
    }

    /* 移动端适配 */
    @media (max-width: 768px) {
        .container {
            left: 0;
        }
        
        .container.expanded {
            left: 0;
        }
        
        .message {
            max-width: 95%;
            padding: 10px;
        }
        
        .message-content {
            font-size: 15px;
            padding: 10px 14px;
        }
        
        .avatar {
            width: 36px;
            height: 36px;
        }
    }

    /* 深色主题优化 */
    [data-theme="dark"] .message-content {
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .file-item.removing {
        animation: fileItemOut 0.3s ease forwards;
    }

    @keyframes fileItemIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes fileItemOut {
        from {
            opacity: 1;
            transform: translateY(0);
        }
        to {
            opacity: 0;
            transform: translateY(-10px);
        }
    }

    /* 添加文件上传区域样式 */
    .file-upload-area {
        position: relative;
        margin-top: 12px;
        padding: 16px;
        border: 2px dashed var(--border-color);
        border-radius: 12px;
        background: var(--file-preview-bg);
        transition: all 0.3s ease;
    }

    .file-upload-area.drag-over {
        border-color: var(--primary-color);
        background: rgba(16, 163, 127, 0.05);
    }

    /* 文件列表样式 */
    .file-list {
        max-width: 1160px;
        width: 100%;
        max-height: 200px;
        overflow-y: auto;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 8px 20px 0 20px;
        padding: 10px;
        background: var(--file-preview-bg);
        border: 1px solid var(--file-border);
        border-radius: 8px;
    }

    .file-item {
        display: flex;
        align-items: center;
        padding: 8px;
        background: var(--background-color);
        border: 1px solid var(--file-border);
        border-radius: 8px;
        max-width: calc(50% - 4px);
        min-width: 200px;
        position: relative;
        transition: all 0.2s ease;
    }

    .file-item:hover {
        border-color: var(--primary-color);
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .file-icon-wrapper {
        margin-right: 8px;
        flex-shrink: 0;
    }

    .file-info {
        flex-grow: 1;
        overflow: hidden;
    }

    .file-name {
        font-weight: 500;
        font-size: 12px;
        color: var(--text-color);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-bottom: 2px;
    }

    .file-size {
        font-size: 10px;
        color: var(--text-color);
        opacity: 0.7;
    }

    .remove-button {
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 4px;
        background: transparent;
        border: none;
        border-radius: 4px;
        color: var(--text-color);
        opacity: 0;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .file-item:hover .remove-button {
        opacity: 0.7;
    }

    .remove-button:hover {
        opacity: 1;
        background: rgba(255, 59, 48, 0.1);
        color: #ff3b30;
    }

    /* 文件类型图标样式 */
    .file-type-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 6px;
    }

    .file-type-icon svg {
        width: 20px;
        height: 20px;
    }

    /* 文件预览样式 */
    .file-preview {
        position: relative;
        margin-top: 8px;
        padding: 12px;
        background: var(--file-preview-bg);
        border-radius: 8px;
        font-size: 14px;
        line-height: 1.6;
        max-height: 200px;
        overflow-y: auto;
    }

    .file-preview pre {
        margin: 0;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    /* 文件上传进度条 */
    .upload-progress {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 0%;
        height: 2px;
        background: var(--primary-color);
        transition: width 0.3s ease;
    }

    /* 添加文件拖放提示 */
    .drag-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 9999;
        align-items: center;
        justify-content: center;
    }

    .drag-overlay.show {
        display: flex;
    }

    .drag-message {
        padding: 20px 40px;
        background: var(--background-color);
        border-radius: 12px;
        font-size: 18px;
        color: var(--text-color);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    }

    /* 自定义滚动条样式 */
    .history-list::-webkit-scrollbar {
        width: 6px;
    }

    .history-list::-webkit-scrollbar-track {
        background: transparent;
    }

    .history-list::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 3px;
    }

    .history-list::-webkit-scrollbar-thumb:hover {
        background: var(--text-color);
    }

    .sidebar.collapsed .sidebar-title,
    .sidebar.collapsed .history-title,
    .sidebar.collapsed .history-date {
        display: none;
    }

    .sidebar.collapsed .new-chat-btn {
        width: 40px;
        height: 40px;
        padding: 8px;
        margin: 8px auto;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .sidebar.collapsed .history-item {
        width: 40px;
        height: 40px;
        padding: 8px;
        margin: 8px auto;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
    }

    .sidebar.collapsed .history-item:hover {
        background: var(--hover-color);
    }

    .sidebar.collapsed .history-item .content {
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0;
    }

    .sidebar.collapsed .history-item .history-title svg {
        margin: 0;
        width: 20px;
        height: 20px;
    }

    .sidebar.collapsed .history-item .history-title,
    .sidebar.collapsed .history-item .history-date,
    .sidebar.collapsed .history-item .delete-btn,
    .sidebar.collapsed .new-chat-btn span {
        display: none;
    }

    .home-btn {
        margin: 8px 20px;
        height: 44px;
        border-radius: 8px;
        background: var(--primary-color);
        color: white;
        border: 1px solid var(--border-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 0 12px;
        font-size: 14px;
        transition: all 0.2s;
        width: calc(100% - 40px);
    }

    .home-btn:hover {
        background: var(--secondary-color);
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .sidebar.collapsed .home-btn {
        width: 40px;
        height: 40px;
        padding: 8px;
        margin: 8px auto;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .sidebar.collapsed .home-btn span {
        display: none;
    }

    .toggle-sidebar {
        background: none;
        border: none;
        color: var(--text-color);
        cursor: pointer;
        padding: 8px;
        border-radius: 50%;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .toggle-sidebar:hover {
        background: rgba(0, 0, 0, 0.1);
    }
    
    .sidebar.collapsed .toggle-sidebar svg {
        transform: rotate(180deg);
    }
    
    [data-theme="dark"] .toggle-sidebar:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    .new-chat-btn span {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* 添加历史记录样式 */
    .history-panel {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        width: 300px;
        background: var(--background-color);
        border-right: 1px solid var(--border-color);
        padding: 20px;
        overflow-y: auto;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        z-index: 1000;
    }

    .history-panel.show {
        transform: translateX(0);
    }

    .history-toggle {
        position: fixed;
        left: 20px;
        top: 20px;
        z-index: 1001;
        padding: 8px 16px;
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .history-toggle:hover {
        background: var(--hover-color);
    }

    .history-item {
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        margin-bottom: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .history-item:hover {
        background: rgba(0, 113, 227, 0.1);
    }

    .history-item .title {
        font-weight: 500;
        margin-bottom: 4px;
    }

    .history-item .timestamp {
        font-size: 12px;
        color: var(--text-color);
        opacity: 0.7;
    }

    .history-item .delete-btn {
        float: right;
        padding: 4px 8px;
        background: var(--error-color);
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 12px;
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .history-item:hover .delete-btn {
        opacity: 1;
    }

    .history-btn {
        margin: 8px 20px;
        height: 44px;
        border-radius: 8px;
        background: var(--primary-color);
        color: white;
        border: 1px solid var(--border-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 0 12px;
        font-size: 14px;
        transition: all 0.2s;
        width: calc(100% - 40px);
    }

    .history-btn:hover {
        background: var(--secondary-color);
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .history-btn svg {
        width: 16px;
        height: 16px;
        stroke: white;
    }

    .sidebar.collapsed .history-btn {
        width: 40px;
        height: 40px;
        padding: 8px;
        margin: 8px auto;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .sidebar.collapsed .history-btn span {
        display: none;
    }

    .loading-dots {
        display: inline-flex;
        align-items: center;
        gap: 4px;
    }
    
    .loading-dots span {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--primary-color);
        animation: bounce 1.4s infinite ease-in-out both;
    }
    
    @keyframes bounce {
        0%, 80%, 100% { 
            transform: translateY(0);
            opacity: 0.5;
        }
        40% { 
            transform: translateY(-6px);
            opacity: 1;
        }
    }

    /* 新增走马灯效果 */
    @keyframes marquee {
        0% {
            background-position: 100% 0;
        }
        100% {
            background-position: -100% 0;
        }
    }

    .message.ai.loading .message-content {
        position: relative;
        overflow: hidden;
        background: linear-gradient(90deg, 
            rgba(16, 163, 127, 0.1) 25%, 
            rgba(16, 163, 127, 0.2) 50%, 
            rgba(16, 163, 127, 0.1) 75%
        );
        background-size: 200% 100%;
        animation: marquee 2s linear infinite;
        border-radius: 12px;
    }

    .message.ai.loading .message-content::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, 
            transparent 25%, 
            rgba(255, 255, 255, 0.3) 50%, 
            transparent 75%
        );
        background-size: 200% 100%;
        animation: marquee 2s linear infinite;
    }

    /* 添加文件显示组件样式 */
    .file-attachment {
        display: flex;
        align-items: center;
        padding: 4px 8px;
        margin: 3px 0;
        background: var(--file-preview-bg);
        border: 1px solid var(--file-border);
        border-radius: 5px;
        transition: all 0.2s ease;
        max-width: 180px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.03);
        cursor: pointer;
        font-size: 0.85em;
    }

    .file-attachment:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
        border-color: var(--primary-color);
    }

    .file-icon-wrapper {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        border-radius: 4px;
        margin-right: 6px;
        flex-shrink: 0;
    }

    .file-icon-wrapper svg {
        width: 14px;
        height: 14px;
    }

    .file-icon-wrapper.pdf {
        background-color: rgba(244, 15, 2, 0.08);
        color: var(--pdf-color);
    }

    .file-icon-wrapper.doc, .file-icon-wrapper.docx {
        background-color: rgba(43, 87, 154, 0.08);
        color: var(--docx-color);
    }

    .file-icon-wrapper.xls, .file-icon-wrapper.xlsx, .file-icon-wrapper.csv {
        background-color: rgba(33, 115, 70, 0.08);
        color: var(--xlsx-color);
    }

    .file-icon-wrapper.txt {
        background-color: rgba(94, 105, 119, 0.08);
        color: var(--txt-color);
    }

    .file-icon-wrapper.json, .file-icon-wrapper.md {
        background-color: rgba(245, 166, 35, 0.08);
        color: var(--json-color);
    }

    .file-icon-wrapper.py, .file-icon-wrapper.js, .file-icon-wrapper.html, 
    .file-icon-wrapper.css, .file-icon-wrapper.java, .file-icon-wrapper.c, 
    .file-icon-wrapper.cpp, .file-icon-wrapper.h, .file-icon-wrapper.php, 
    .file-icon-wrapper.sql {
        background-color: rgba(66, 133, 244, 0.08);
        color: var(--code-color);
    }

    .file-icon-wrapper.jpg, .file-icon-wrapper.jpeg, .file-icon-wrapper.png, 
    .file-icon-wrapper.gif, .file-icon-wrapper.bmp {
        background-color: rgba(142, 68, 173, 0.08);
        color: var(--image-color);
    }

    .file-icon-wrapper.zip, .file-icon-wrapper.rar, .file-icon-wrapper[class*="7z"] {
        background-color: rgba(249, 168, 37, 0.08);
        color: var(--zip-color);
    }

    .file-icon-wrapper.default {
        background-color: rgba(96, 125, 139, 0.08);
        color: var(--default-file-color);
    }

    .file-details {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }

    .file-name {
        font-weight: 500;
        font-size: 11px;
        color: var(--text-color);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-bottom: 1px;
    }

    .file-meta {
        display: flex;
        font-size: 9px;
        color: var(--text-color);
        opacity: 0.7;
    }

    .file-size {
        font-size: 9px;
    }

    .file-thumbnail {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        object-fit: cover;
        margin-right: 10px;
        flex-shrink: 0;
    }

    /* 添加文件组样式 */
    .file-attachments-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin: 6px 0;
        width: 100%;
    }

    /* 文件预览窗口样式 */
    .file-preview-panel {
        position: fixed;
        top: 100px;
        right: 20px;
        width: 360px;
        height: calc(100vh - 200px);
        background: var(--background-color);
        border: 1px solid var(--border-color);
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        z-index: 1050;
        display: none;
        flex-direction: column;
        overflow: hidden;
        transition: all 0.3s ease;
    }

    .file-preview-panel.show {
        display: flex;
    }

    .file-preview-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        border-bottom: 1px solid var(--border-color);
    }

    .file-preview-title {
        font-weight: 500;
        font-size: 14px;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
    }

    .file-preview-close {
        background: transparent;
        border: none;
        color: var(--text-color);
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        margin-left: 8px;
    }

    .file-preview-close:hover {
        background: rgba(0, 0, 0, 0.05);
    }

    .file-preview-content {
        flex: 1;
        overflow: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
    }

    .file-preview-content img {
        max-width: 100%;
        max-height: 80%;
        object-fit: contain;
    }

    .file-preview-text {
        width: 100%;
        height: 100%;
        overflow: auto;
        font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.5;
        white-space: pre-wrap;
        padding: 8px;
        background: var(--file-preview-bg);
        border-radius: 4px;
    }
    
    .file-preview-info {
        margin-top: 16px;
        font-size: 12px;
        color: var(--text-color);
        opacity: 0.6;
        width: 100%;
        text-align: center;
    }

    .file-type-label {
        display: inline-block;
        padding: 1px 4px;
        border-radius: 2px;
        font-size: 8px;
        font-weight: 500;
        text-transform: uppercase;
        margin-right: 4px;
        background: var(--file-preview-bg);
    }

    /* 在样式部分添加版本导航的样式 */
    .response-versions-nav {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        color: var(--text-color);
        font-size: 14px;
        opacity: 1; /* 设置为1，让它与其他按钮一起显示/隐藏 */
        margin-left: 6px; /* 与重新生成按钮的间距 */
        transition: opacity 0.3s ease;
    }

    .version-nav-btn {
        background: none;
        border: none;
        color: var(--text-color);
        cursor: pointer;
        padding: 4px;
        font-size: 14px;
        opacity: 0.7;
        transition: all 0.2s ease;
    }

    .version-nav-btn:hover {
        opacity: 1;
        transform: scale(1.1);
    }

    .version-nav-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        transform: scale(1);
    }
    
    /* 版本信息样式 */
    .version-info {
        font-size: 12px;
        padding: 0 2px;
        color: var(--text-color);
        opacity: 0.8;
    }

    /* 删除不再需要的规则 */
    /* .message.ai:hover .response-versions-nav {
        opacity: 1;
    } */
    
    /* 版本切换动画 */
    @keyframes fadeInVersion {
        from { opacity: 0; transform: translateY(5px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    .version-transition {
        animation: fadeInVersion 0.3s ease forwards;
    }

    /* 拖放相关样式 */
    .input-wrapper.drag-over {
        border-color: var(--primary-color);
        background-color: rgba(16, 163, 127, 0.05);
        box-shadow: 0 0 0 2px rgba(16, 163, 127, 0.2);
    }
    
    /* 用户消息编辑按钮样式 */
    .edit-user-message-btn {
        position: absolute !important;
        left: -34px !important; /* 精确调整位置，紧贴消息框 */
        top: 50% !important;
        transform: translateY(-50%) !important;
        width: 28px !important;
        height: 28px !important;
        border-radius: 50% !important;
        background: var(--primary-color) !important;
        border: 1px solid var(--border-color) !important;
        color: white !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        opacity: 0 !important; /* 默认隐藏 */
        transition: all 0.2s ease !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
        z-index: 100 !important;
    }
    
    /* 用户消息悬停时显示编辑按钮 */
    .message.user:hover .edit-user-message-btn {
        opacity: 0.9 !important; /* 提高默认不透明度 */
    }
    
    /* 鼠标悬停效果 */
    .edit-user-message-btn:hover {
        opacity: 1 !important;
        background-color: var(--secondary-color) !important; /* 使用次要颜色增加区分度 */
        transform: translateY(-50%) scale(1.1) !important;
    }

    .message.user.editing .message-content {
        background: rgba(45, 155, 240, 0.08);
        outline: 2px solid var(--primary-color);
        color: #333333; /* 添加深色文字颜色，确保在浅色模式下可见 */
        padding: 10px; /* 增加内边距使内容更清晰 */
        border-radius: 6px; /* 圆角边框 */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* 增强阴影 */
        min-height: 60px; /* 确保足够的高度 */
    }
    
    /* 确保浅色模式下的对比度 */
    [data-theme="light"] .message.user.editing .message-content {
        background: rgba(45, 155, 240, 0.12); /* 稍微加深背景色 */
        color: #000000; /* 使用黑色文字 */
        border: 1px solid rgba(45, 155, 240, 0.3); /* 添加边框 */
    }
    
    /* 确保深色模式下的对比度 */
    [data-theme="dark"] .message.user.editing .message-content {
        background: rgba(45, 155, 240, 0.2); /* 加深背景色 */
        color: #ffffff; /* 使用白色文字 */
        border: 1px solid rgba(45, 155, 240, 0.5); /* 添加边框 */
    }
    
    /* 编辑状态下覆盖用户消息的默认样式 */
    .message.user.editing .message-content {
        background: #f5f9ff !important; /* 适合浅色模式的背景 */
        color: #333333 !important; /* 深色文字 */
        font-weight: normal !important; /* 正常字重 */
    }
    
    /* 深色模式下的编辑框 */
    [data-theme="dark"] .message.user.editing .message-content {
        background: #2d3748 !important; /* 深色模式背景 */
        color: #f7fafc !important; /* 浅色文字 */
    }
    
    .message.user.editing .message-content[contenteditable="true"] {
        min-height: 40px;
        caret-color: var(--primary-color); /* 设置光标颜色 */
        padding: 12px; /* 增加内边距 */
        line-height: 1.5; /* 增加行高 */
    }
    
    .edit-actions {
        display: flex;
        gap: 8px;
        margin-top: 12px;
        justify-content: flex-end;
    }
    
    .edit-actions button {
        padding: 6px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--background-color);
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s ease;
        font-weight: 500;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    .edit-actions .save-edit-btn {
        background: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
    }
    
    .edit-actions .cancel-edit-btn {
        background: transparent;
        color: var(--text-color);
    }
    
    [data-theme="dark"] .edit-actions .cancel-edit-btn {
        background: rgba(255, 255, 255, 0.05);
        border-color: rgba(255, 255, 255, 0.1);
    }
    
    .edit-actions .save-edit-btn:hover {
        background: var(--hover-color);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
    
    .edit-actions .cancel-edit-btn:hover {
        background: rgba(0, 0, 0, 0.05);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    
    [data-theme="dark"] .edit-actions .cancel-edit-btn:hover {
        background: rgba(255, 255, 255, 0.1);
    }
    
    .edit-actions button:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    /* 输入框左侧的编辑按钮样式 */
    .edit-input-btn {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: var(--background-color);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        position: absolute;
        left: -40px; /* 修改按钮位置，确保不会被输入框遮挡 */
        top: 50%;
        transform: translateY(-50%);
        z-index: 1000;
        transition: all 0.2s ease;
    }
    
    .edit-input-btn:hover {
        background-color: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
    }
    
    /* 确保输入容器有足够空间放置按钮 */
    .input-wrapper {
        max-width: 1160px;
        width: calc(100% - 40px); /* 修改为减去内边距的100%宽度 */
        position: relative;
        display: flex;
        align-items: center;
        background: var(--chat-bg);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 12px 16px; /* 调整内边距，确保右侧和左侧有足够的空间 */
        margin: 20px auto 0; /* 使用auto自动计算左右外边距使其居中 */
        transition: all 0.3s ease;
        z-index: 1002;
        box-sizing: border-box; /* 确保内边距包含在宽度内 */
    }

    /* 用户消息版本导航样式 */
    .user-versions-nav {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        color: var(--text-color);
        font-size: 14px;
        opacity: 0.7;
        margin-left: 6px;
        transition: opacity 0.3s ease;
    }
    
    .message.user:hover .user-versions-nav {
        opacity: 1;
    }
    
    .user-version-nav-btn {
        background: none;
        border: none;
        color: var(--text-color);
        cursor: pointer;
        padding: 4px;
        font-size: 14px;
        opacity: 0.7;
        transition: all 0.2s ease;
    }
    
    .user-version-nav-btn:hover {
        opacity: 1;
        transform: scale(1.1);
    }
    
    .user-version-nav-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        transform: scale(1);
    }
    
    .user-version-info {
        font-size: 12px;
        padding: 0 2px;
        color: var(--text-color);
        opacity: 0.8;
    }
    
    /* 用户消息版本切换动画 */
    @keyframes fadeInUserVersion {
        from { opacity: 0; transform: translateY(5px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    .user-version-transition {
        animation: fadeInUserVersion 0.3s ease forwards;
    }

    /* 响应式布局调整 */
    @media (max-width: 768px) {
        .input-wrapper {
            max-width: calc(100% - 40px); /* 确保在小屏幕上有合适的宽度 */
        }
        
        .edit-input-btn {
            left: -30px; /* 在小屏幕上调整按钮位置 */
        }
        
        .sidebar.collapsed + .container .input-container {
            left: 60px;
            width: calc(100% - 60px); /* 确保侧边栏收缩时输入框宽度正确 */
            padding-left: 25px; /* 在小屏幕上增加更多左侧内边距 */
        }
        
        .sidebar.collapsed + .container .input-wrapper {
            margin-left: 25px; /* 在小屏幕上为输入框添加更多左侧边距 */
            width: calc(100% - 90px); /* 减少宽度，确保不会超出容器 */
        }
    }

    /* 侧边栏收缩时的输入容器样式 */
    .sidebar.collapsed + .container .input-container {
        left: 60px;
        padding-left: 20px; /* 增加左侧内边距，防止输入框紧贴侧边栏 */
    }
    
    /* 侧边栏收缩时特别调整输入框样式 */
    .sidebar.collapsed + .container .input-wrapper {
        margin-left: 20px; /* 为输入框添加更多左侧边距 */
        width: calc(100% - 80px); /* 减少宽度，确保不会超出容器 */
        position: relative; /* 确保可以添加伪元素 */
    }
    
    /* 添加一个左侧保护区域 */
    .sidebar.collapsed + .container .input-wrapper::before {
        content: '';
        position: absolute;
        left: -20px;
        top: 0;
        bottom: 0;
        width: 20px; /* 保护区域宽度 */
        background: var(--background-color); /* 与背景相同的颜色 */
        z-index: 50; /* 确保在较高层级 */
    }
    
    /* 侧边栏收缩状态下，隐藏部分占位符文本内容，仅保留更简短的提示 */
    @media (max-width: 992px) {
        .sidebar.collapsed + .container textarea::placeholder {
            content: "输入问题..."; /* 简化占位符文本 */
        }
    }

    /* 停止生成按钮样式 */
    .send-button.stop-button {
        background-color: var(--stop-button-color);
        color: white;
    }

    .send-button.stop-button:hover {
        background-color: var(--stop-button-hover);
    }

    .send-button.stop-button svg {
        stroke: white;
        fill: white;
    }

    /* 调整用户消息样式 */
    .message.user {
        margin-left: 40px !important; /* 增加左侧边距，为编辑按钮留出空间 */
    }

    .message.user .message-content {
        word-wrap: break-word !important; /* 确保长文本会换行 */
        word-break: break-word !important; /* 适用于非英文字符 */
        overflow-wrap: break-word !important; /* 现代浏览器支持 */
        max-width: 100% !important; /* 确保内容不会超出容器 */
    }

    .history-btn span {
        font-size: 14px;
    }
    
    /* 设置按钮样式 */
    .settings-btn {
        margin: 8px 20px;
        height: 44px;
        border-radius: 8px;
        background: var(--primary-color);
        color: white;
        border: 1px solid var(--border-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 0 12px;
        font-size: 14px;
        transition: all 0.2s;
        width: calc(100% - 40px);
    }

    .settings-btn:hover {
        background: var(--secondary-color);
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .settings-btn svg {
        width: 16px;
        height: 16px;
        stroke: white;
    }

    .sidebar.collapsed .settings-btn {
        width: 40px;
        height: 40px;
        padding: 8px;
        margin: 8px auto;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .sidebar.collapsed .settings-btn span {
        display: none;
    }
    
    /* 设置面板样式 */
    .settings-panel {
        flex: 1;
        overflow-y: auto;
        padding: 12px 16px;
        display: none;
        color: var(--text-color);
    }
    
    .settings-panel h3 {
        margin: 0 0 16px 0;
        font-size: 16px;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--border-color);
    }
    
    .settings-section {
        margin-bottom: 20px;
    }
    
    /* 设置项样式 */
    .settings-section h4 {
        font-size: 14px;
        margin: 0 0 12px 0;
        color: var(--primary-color);
    }
    
    .setting-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px dashed var(--border-color);
    }
    
    .setting-item:last-child {
        border-bottom: none;
    }
    
    .setting-item label {
        font-size: 14px;
    }
    
    /* 设置提示信息样式 */
    .setting-hint {
        font-size: 12px;
        margin-top: 5px;
        text-align: center;
        padding: 8px;
        border-radius: 6px;
        background-color: rgba(0, 0, 0, 0.05);
        color: var(--text-color);
        opacity: 0.6;
    }
    
    [data-theme="dark"] .setting-hint {
        background-color: rgba(255, 255, 255, 0.05);
    }
    
    /* 开关按钮样式 */
    .switch-container {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 20px;
    }
    
    .toggle-switch {
        opacity: 0;
        width: 0;
        height: 0;
    }
    
    .toggle-label {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 34px;
    }
    
    .toggle-label:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }
    
    .toggle-switch:checked + .toggle-label {
        background-color: var(--primary-color);
    }
    
    .toggle-switch:checked + .toggle-label:before {
        transform: translateX(20px);
    }
    
    /* 单选按钮组样式 */
    .radio-group {
        display: flex;
        gap: 12px;
    }
    
    .radio-option {
        display: flex;
        align-items: center;
        gap: 4px;
        cursor: pointer;
    }
    
    .radio-option input[type="radio"] {
        appearance: none;
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border: 2px solid #ccc;
        border-radius: 50%;
        outline: none;
        cursor: pointer;
    }
    
    .radio-option input[type="radio"]:checked {
        border-color: var(--primary-color);
        background: var(--primary-color);
        box-shadow: inset 0 0 0 3px white;
    }
    
    .radio-option span {
        font-size: 13px;
    }
    
    /* 气泡样式选项 */
    .bubble-options {
        display: flex;
        gap: 12px;
        justify-content: space-between;
    }
    
    .bubble-option {
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
    }
    
    .bubble-option input[type="radio"] {
        appearance: none;
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border: 2px solid #ccc;
        border-radius: 50%;
        outline: none;
        cursor: pointer;
        margin-bottom: 5px;
    }
    
    .bubble-option input[type="radio"]:checked {
        border-color: var(--primary-color);
        background: var(--primary-color);
        box-shadow: inset 0 0 0 3px white;
    }
    
    .bubble-preview {
        display: block;
        width: 40px;
        height: 24px;
        background: linear-gradient(135deg, #5a67d8 0%, #3b7cdd 100%);
        position: relative;
        overflow: hidden;
    }
    
    .bubble-preview::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, 
            rgba(255,255,255,0.07) 0%, 
            rgba(255,255,255,0.13) 50%, 
            rgba(255,255,255,0.07) 100%);
        background-size: 200% 100%;
        animation: bubbleMarquee 3s ease-in-out infinite;
        z-index: 0;
        pointer-events: none;
    }
    
    @keyframes bubbleMarquee {
        0% {
            background-position: 100% 0;
        }
        100% {
            background-position: -100% 0;
        }
    }
    
    .bubble-preview.square {
        border-radius: 4px;
    }
    
    .bubble-preview.rounded {
        border-radius: 10px;
    }
    
    .bubble-preview.pill {
        border-radius: 24px;
    }
    
    .bubble-preview.flat {
        border-radius: 0;
        border-left: 3px solid #5a67d8;
        background: linear-gradient(135deg, rgba(90, 103, 216, 0.1) 0%, rgba(59, 124, 221, 0.1) 100%);
    }
    
    /* 字体大小样式类 */
    .font-size-small {
        font-size: 14px !important;
    }
    
    .font-size-medium {
        font-size: 16px !important;
    }
    
    .font-size-large {
        font-size: 18px !important;
    }
    
    /* 字体样式类 */
    .font-family-system {
        font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial !important;
    }
    
    .font-family-serif {
        font-family: "Times New Roman", Times, SimSun, serif !important;
    }
    
    .font-family-sans-serif {
        font-family: Arial, Helvetica, "Microsoft YaHei", sans-serif !important;
    }
    
    .font-family-handwritten {
        font-family: "Comic Sans MS", "Comic Sans", cursive, "KaiTi", "楷体", "FangSong", "仿宋", "STKaiti", "华文楷体" !important;
    }
    
    .font-family-elegant {
        font-family: "Palatino Linotype", "Book Antiqua", "Palatino", "STSong", "华文宋体", "NSimSun", "新宋体", Georgia, serif !important;
    }
    
    .font-family-rounded {
        font-family: "Varela Round", "Hiragino Maru Gothic ProN", "Rounded Mplus 1c", "Kosugi Maru", "Quicksand", "Comfortaa", "Yuanti SC", "圆体-简", "圆体", sans-serif !important;
    }
    
    .font-family-tech {
        font-family: "Space Mono", "Fira Code", "Source Code Pro", "Menlo", Monaco, "Courier New", monospace !important;
    }
    
    .font-family-brush {
        font-family: "华文行楷", "STXingkai", "楷体", "KaiTi", "Brush Script MT", cursive !important;
    }
    
    /* 消息气泡样式类 */
    .bubble-style-square .message-content {
        border-radius: 4px !important;
    }
    
    .bubble-style-rounded .message-content {
        border-radius: 10px !important;
    }
    
    .bubble-style-pill .message-content {
        border-radius: 24px !important;
    }
    
    .bubble-style-flat .message-content {
        border-radius: 0 !important;
        border-left: 3px solid var(--primary-color) !important;
        background-color: rgba(16, 163, 127, 0.05) !important;
    }
    
    .bubble-style-flat .message.user .message-content {
        border-left: 3px solid #3b82f6 !important;
        background-color: rgba(59, 130, 246, 0.05) !important;
        color: var(--text-color) !important; /* 使用文本颜色变量替代固定白色 */
    }
    
    /* 其他样式 */

    /* 字体样式选项 */
    .font-options-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        margin-top: 10px;
    }
    
    .font-option {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        padding: 8px 4px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: all 0.2s ease;
        background-color: var(--background-color);
        position: relative;
    }
    
    .font-option:hover {
        border-color: var(--primary-color);
        background-color: rgba(16, 163, 127, 0.05);
    }
    
    .font-option input[type="radio"] {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
    }
    
    .font-option input[type="radio"]:checked + span {
        color: var(--primary-color);
        font-weight: 500;
    }
    
    .font-option input[type="radio"]:checked + span::after {
        content: "";
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 2px;
        background-color: var(--primary-color);
        border-radius: 1px;
    }
    
    .font-option span {
        margin-top: 2px;
        font-size: 12px;
        position: relative;
        padding-bottom: 3px;
    }
    
    /* 字体预览样式 */
    .font-option[value="system"] span {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    
    .font-option[value="serif"] span {
        font-family: Georgia, Times, "Times New Roman", serif;
    }
    
    .font-option[value="sans-serif"] span {
        font-family: Arial, Helvetica, sans-serif;
    }
    
    .font-option[value="handwritten"] span {
        font-family: "Comic Sans MS", cursive, sans-serif;
    }
    
    .font-option[value="elegant"] span {
        font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
    }
    
    .font-option[value="rounded"] span {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        letter-spacing: 0.5px;
    }
    
    .font-option[value="tech"] span {
        font-family: "Courier New", Courier, monospace;
    }
    
    .font-option[value="brush"] span {
        font-family: "华文行楷", "STXingkai", "楷体", "KaiTi", "Brush Script MT", cursive;
    }
    
    /* 选中状态 */
    .font-option input[type="radio"]:checked + span::before {
        content: "";
        position: absolute;
        top: -18px;
        left: 50%;
        transform: translateX(-50%);
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background-color: var(--primary-color);
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' width='12' height='12'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: center;
        background-size: 10px;
    }
    
    /* 深色模式下的调整 */
    [data-theme="dark"] .font-option {
        background-color: var(--background-color);
        border-color: var(--border-color);
    }
    
    [data-theme="dark"] .font-option:hover {
        background-color: rgba(255, 255, 255, 0.05);
        border-color: var(--primary-color);
    }

    .radio-option:hover {
        background-color: rgba(0, 0, 0, 0.05);
        border-radius: 6px;
        transition: background-color 0.2s;
    }
    
    [data-theme="dark"] .radio-option:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }

    .setting-hint {
        font-size: 12px;
        color: var(--text-color);
        opacity: 0.7;
        margin-top: 10px;
    }
    
    /* 滑块样式 */
    .slider-container {
        width: 100%;
        margin: 10px 0;
    }
    
    .slider {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 4px;
        border-radius: 5px;
        background: var(--border-color);
        outline: none;
    }
    
    .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--primary-color);
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .slider::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--primary-color);
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .slider::-webkit-slider-thumb:hover {
        background: var(--secondary-color);
        transform: scale(1.1);
    }
    
    .slider::-moz-range-thumb:hover {
        background: var(--secondary-color);
        transform: scale(1.1);
    }
    
    .font-size-preview {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 5px;
        color: var(--text-color);
        opacity: 0.8;
    }
    
    .font-size-preview span {
        padding: 0 5px;
        font-weight: 500;
    }
    
    .font-size-preview .slider-container {
        flex: 1;
        margin: 0 8px;
    }
    
    .font-size-preview-large {
        font-size: 1.5em;
        font-weight: 500;
    }
    
    /* 聊天消息设置样式 */
</style>

<!-- 侧边栏 -->
<div class="sidebar" id="sidebar">
    <div class="sidebar-header">
        <h2 class="sidebar-title">项目栏</h2>
        <button class="toggle-sidebar" onclick="toggleSidebar()" title="收起/展开侧边栏">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
        </button>
    </div>
    <button class="home-btn" onclick="window.location.href='/'" title="返回主页">
        <svg stroke="currentColor" fill="none" stroke-width="1.5" viewBox="0 0 24 24" height="24" width="24">
            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
            <polyline points="9 22 9 12 15 12 15 22"></polyline>
        </svg>
        <span>返回主页</span>
    </button>
    <button class="new-chat-btn" onclick="startNewChat()" title="开始新的对话">
        <svg stroke="currentColor" fill="none" stroke-width="1.5" viewBox="0 0 24 24" height="24" width="24">
            <path d="M12 5v14M5 12h14" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
        <span>新建对话</span>
    </button>
    <button class="settings-btn" onclick="toggleSettings()" title="设置">
        <svg stroke="currentColor" fill="none" stroke-width="1.5" viewBox="0 0 24 24" height="24" width="24">
            <path d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" stroke-linecap="round" stroke-linejoin="round"></path>
            <path d="M12 15a3 3 0 100-6 3 3 0 000 6z" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
        <span>设置</span>
    </button>
    <button class="history-btn" onclick="toggleHistory()" title="查看历史对话记录">
        <svg stroke="currentColor" fill="none" stroke-width="1.5" viewBox="0 0 24 24" height="24" width="24">
            <path d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
        <span>历史记录</span>
    </button>
    <div class="history-list" id="historyList">
        <!-- 历史对话项会动态添加到这里 -->
    </div>
    <div class="settings-panel" id="settingsPanel" style="display: none;">
        <h3>设置</h3>
        
        <!-- 外观设置 -->
        <div class="settings-section">
            <h4>外观设置</h4>
            
            <!-- 字体大小滑块 -->
            <div class="setting-item">
                <label>字体</label>
                <div class="font-size-preview">
                    <span>小</span>
                    <div class="slider-container">
                        <input type="range" id="fontSizeSlider" min="12" max="24" value="16" step="1" class="slider">
                    </div>
                    <span class="font-size-preview-large">大</span>
                </div>
            </div>
            
            <!-- 字体样式 -->
            <div class="setting-item">
                <label>字体样式</label>
                <div class="font-options-grid">
                    <label class="font-option" value="system">
                        <input type="radio" name="fontFamily" value="system" checked>
                        <span>系统默认</span>
                    </label>
                    <label class="font-option" value="serif">
                        <input type="radio" name="fontFamily" value="serif">
                        <span>衬线字体</span>
                    </label>
                    <label class="font-option" value="sans-serif">
                        <input type="radio" name="fontFamily" value="sans-serif">
                        <span>无衬线字体</span>
                    </label>
                    <label class="font-option" value="handwritten">
                        <input type="radio" name="fontFamily" value="handwritten">
                        <span>手写体</span>
                    </label>
                    <label class="font-option" value="elegant">
                        <input type="radio" name="fontFamily" value="elegant">
                        <span>优雅字体</span>
                    </label>
                    <label class="font-option" value="rounded">
                        <input type="radio" name="fontFamily" value="rounded">
                        <span>圆润字体</span>
                    </label>
                    <label class="font-option" value="tech">
                        <input type="radio" name="fontFamily" value="tech">
                        <span>科技感</span>
                    </label>
                    <label class="font-option" value="brush">
                        <input type="radio" name="fontFamily" value="brush">
                        <span>书法字体</span>
                    </label>
                </div>
            </div>
            
            <!-- 消息气泡样式 -->
            <div class="setting-item">
                <label>消息气泡样式</label>
                <div class="bubble-options">
                    <label class="bubble-option" title="方角">
                        <input type="radio" name="bubbleStyle" value="square" checked>
                        <span class="bubble-preview square"></span>
                    </label>
                    <label class="bubble-option" title="圆角">
                        <input type="radio" name="bubbleStyle" value="rounded">
                        <span class="bubble-preview rounded"></span>
                    </label>
                    <label class="bubble-option" title="圆边">
                        <input type="radio" name="bubbleStyle" value="pill">
                        <span class="bubble-preview pill"></span>
                    </label>
                    <label class="bubble-option" title="扁平">
                        <input type="radio" name="bubbleStyle" value="flat">
                        <span class="bubble-preview flat"></span>
                    </label>
                </div>
            </div>
        </div>
        
        <!-- 交互体验设置 -->
        <div class="settings-section">
            <h4>交互体验设置</h4>
            
            <!-- 打字机效果开关 -->
            <div class="setting-item">
                <label for="typewriterEffect">打字机效果</label>
                <div class="switch-container">
                    <input type="checkbox" id="typewriterEffect" class="toggle-switch" checked>
                    <label for="typewriterEffect" class="toggle-label"></label>
                </div>
            </div>
            
            <!-- 打字机效果速度 -->
            <div class="setting-item" id="typewriterSpeedSetting">
                <label>打字机效果速度</label>
                <div class="radio-group">
                    <label class="radio-option">
                        <input type="radio" name="typewriterSpeed" value="slow">
                        <span>慢</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="typewriterSpeed" value="medium" checked>
                        <span>中</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="typewriterSpeed" value="fast">
                        <span>快</span>
                    </label>
                </div>
            </div>
            
            <!-- 滚动行为 -->
            <div class="setting-item">
                <label>滚动行为</label>
                <div class="radio-group">
                    <label class="radio-option">
                        <input type="radio" name="scrollBehavior" value="auto" checked>
                        <span>自动</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="scrollBehavior" value="manual">
                        <span>手动</span>
                    </label>
                </div>
            </div>
            
            <!-- 提示信息 -->
            <div class="setting-hint">
               注：交互体验设置的更改将在下次AI回复时生效
            </div>
        </div>
    </div>
</div>

<!-- 主体内容 -->
<div class="container">
    <div class="chat-container">
        <!-- 聊天标题 -->
        <div id="chatTitle" class="chat-title" style="display: none;">
            <h3 id="chatTitleText"></h3>
        </div>
        
        <!-- 聊天消息区域 -->
        <div id="chatMessages" class="chat-messages">
            <!-- 消息内容会动态添加到这里 -->
        </div>
    </div>
</div>

<!-- 单独的输入区域，与侧边栏平级 -->
<div class="input-container">
    <div class="input-wrapper">
        <textarea id="userInput" placeholder="输入您的问题... (Shift + Enter 换行)" rows="1" title="在此输入您的问题，按Shift + Enter可以换行"></textarea>
        <div class="input-tools">
            <button class="tool-button upload-button" id="uploadButton" title="上传文件进行分析">
                <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24">
                    <path d="M12 5v14M5 12h14"></path>
                </svg>
            </button>
            <button class="send-button" onclick="sendMessage()" title="发送消息">
                <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24">
                    <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"></path>
                </svg>
            </button>
        </div>
    </div>
    <div id="fileList" class="file-list" style="display: none;"></div>
    <input type="file" id="fileInput" style="display: none;" multiple accept=".xlsx,.xls,.jpg,.jpeg,.png,.gif,.pdf,.doc,.docx,.txt,.csv,.json,.md,.py,.js,.html,.css,.java,.c,.cpp,.h,.php,.sql">
</div>

<!-- 文件预览面板 -->
<div id="filePreviewPanel" class="file-preview-panel">
    <div class="file-preview-header">
        <h3 class="file-preview-title" id="previewFileName">文件预览</h3>
        <button class="file-preview-close" onclick="closeFilePreview()">
            <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="16" width="16">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
    </div>
    <div class="file-preview-content" id="previewContent">
        <!-- 预览内容将在这里动态生成 -->
    </div>
</div>

<!-- 消息模板 -->
<template id="messageTemplate">
    <div class="message">
        <div class="avatar">
            <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8Y2lyY2xlIGN4PSIyNTYiIGN5PSIxMjgiIHI9IjY0IiBmaWxsPSIjMDA3MWUzIi8+CiAgICA8cGF0aCBkPSJNMzg0IDM4NGMwLTcwLjctNTcuMy0xMjgtMTI4LTEyOGMwIDE3LjcgMTQuMyAzMiAzMmgxOTJjMTcuNyAwIDMyLTE0LjMgMzItMzJ6IiBmaWxsPSIjMDA3MWUzIi8+Cjwvc3ZnPg==" alt="avatar">
        </div>
        <button class="edit-user-message-btn" title="编辑消息内容" onclick="startEditUserMessage(this)">
            <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="12" width="12">
                <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V7.242a2 2 0 00-.602-1.43L16.083 2.57A2 2 0 0014.685 2H10a2 2 0 00-2 2z"></path>
                <path d="M18.54 8.46a5 5 0 010 7.07"></path>
                <path d="M19.07 4.93a10 10 0 010 14.14"></path>
            </svg>
        </button>
        <div class="message-wrapper">
            <div class="message-content"></div>
            <div class="message-actions">
                <button class="action-btn copy-btn" onclick="copyMessage(this)" title="复制此条消息的内容">
                    <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="16" width="16">
                        <path d="M8 4v12a2 2 0 002 2h8a2 2 0 002-2V7.242a2 2 0 00-.602-1.43L16.083 2.57A2 2 0 0014.685 2H10a2 2 0 00-2 2z"></path>
                        <path d="M16 18v2a2 2 0 01-2 2H6a2 2 0 01-2-2V9a2 2 0 012-2h2"></path>
                    </svg>
                    复制
                </button>
                <button class="action-btn speak-btn" onclick="speakMessage(this)" title="朗读此条消息的内容">
                    <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="16" width="16">
                        <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                        <path d="M15.54 8.46a5 5 0 010 7.07"></path>
                        <path d="M19.07 4.93a10 10 0 010 14.14"></path>
                    </svg>
                    朗读
                </button>
                <button class="action-btn regenerate-btn" onclick="regenerateResponse(this)" title="重新生成AI的回答">
                    <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="16" width="16">
                        <path d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c-4.97 0-9-4.03-9-9m9 9a9 9 0 009-9"></path>
                    </svg>
                    重新生成
                </button>
            </div>
        </div>
    </div>
</template>

<script>
// 全局变量 - 用于存储所有已上传文件
const uploadedFiles = [];

// 全局变量 - 用于跟踪AI消息生成状态
window.isGeneratingResponse = false;
window.stopResponseGeneration = false;

// 全局变量 - 用于输入法状态跟踪
window.isIMEComposing = false;
window.lastIMEEndTime = 0;

// 在生产环境中禁用console.log
(function() {
    const isProduction = true; // 设置为true以禁用所有console.log
    
    if (isProduction) {
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;
        
        console.log = function() {
            // 在生产环境中不输出任何内容
        };
        
        console.warn = function() {
            // 只保留关键警告，其余不输出
        };
        
        console.error = function(message) {
            // 保留错误日志，但不输出详细信息
            originalConsoleError("发生错误，请联系管理员");
        };
        
        // 可选：保留一个方法来恢复原始行为（用于调试）
        console.enableLogs = function() {
            console.log = originalConsoleLog;
            console.warn = originalConsoleWarn;
            console.error = originalConsoleError;
        };
    }
})();

document.addEventListener('DOMContentLoaded', function() {
    // 初始化设置
    initSettings();
    
    // 初始化历史记录列表
    updateHistoryList();
    
    // 初始化文件上传相关事件
    setupFileUpload();
    
    // 加载主题设置
    const theme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', theme);

    // 初始化欢迎消息
    addMessage('您好！我是AI助手。我可以帮您分析Excel数据，也可以回答您的其他问题。如果需要数据分析，请上传Excel文件后告诉我您想了解什么。', 'ai');
    
    // 初始化语音功能
    initSpeechFunction();
    
    // 设置输入框键盘事件和输入法事件
    setupUserInputEvents();
    
    // 添加关于文件会话存储的说明日志
    
    // 获取侧边栏切换按钮和侧边栏元素
    const toggleSidebarBtn = document.getElementById('toggleSidebar') || { addEventListener: function(){} };
    const sidebar = document.querySelector('.sidebar');
    const userInput = document.getElementById('userInput');
    const originalPlaceholder = "输入您的问题... (Shift + Enter 换行)";
    const shortPlaceholder = "输入问题...";
    
    // 检查是否应该使用简短占位符
    function updatePlaceholder() {
        if (sidebar.classList.contains('collapsed') && window.innerWidth < 992) {
            userInput.placeholder = shortPlaceholder;
        } else {
            userInput.placeholder = originalPlaceholder;
        }
    }
    
    // 初始调用一次
    updatePlaceholder();
    
    // 侧边栏切换时更新占位符
    toggleSidebarBtn.addEventListener('click', function() {
        setTimeout(updatePlaceholder, 50); // 短暂延迟确保类已应用
    });
    
    // 窗口大小改变时更新占位符
    window.addEventListener('resize', updatePlaceholder);

    // 添加新的侧边栏切换函数
    window.toggleSidebar = function() {
        const sidebar = document.getElementById('sidebar');
        const container = document.querySelector('.container');
        const inputContainer = document.querySelector('.input-container');
        const historyList = document.getElementById('historyList');
        const settingsPanel = document.getElementById('settingsPanel');
        
        // 切换侧边栏收缩状态
        sidebar.classList.toggle('collapsed');
        
        // 更新本地存储中的状态
        const isCollapsed = sidebar.classList.contains('collapsed');
        localStorage.setItem('sidebarCollapsed', isCollapsed);
        
        // 如果侧边栏收缩，则隐藏历史记录和设置面板
        if (isCollapsed) {
            historyList.style.display = 'none';
            settingsPanel.style.display = 'none';
        }
        
        // 触发窗口大小变化事件，让其他组件响应
        window.dispatchEvent(new Event('resize'));
    }

    // 全局拼音输入状态标记
    window.isIMEComposing = false;
    // 增加时间戳标记最后一次输入法结束时间，帮助判断边缘情况
    window.lastIMEEndTime = 0;
});

// 移除可能存在的旧版本事件监听器
function removeOldEventListeners() {
    const userInput = document.getElementById('userInput');
    if (!userInput) return;
    
    // 创建新的输入框元素
    const newInput = userInput.cloneNode(true);
    
    // 替换旧的输入框
    if (userInput.parentNode) {
        userInput.parentNode.replaceChild(newInput, userInput);
    }
    
    return newInput;
}

// 设置用户输入框的所有事件
function setupUserInputEvents() {
    // 移除旧的事件监听器
    const newUserInput = removeOldEventListeners();
    if (!newUserInput) {
        console.error('无法找到或重置输入框元素');
        return;
    }
    
    // 确保发送按钮仅绑定一次事件
    const sendButton = document.querySelector('.send-button');
    if (sendButton) {
        // 移除可能的旧事件
        const newSendButton = sendButton.cloneNode(true);
        if (sendButton.parentNode) {
            sendButton.parentNode.replaceChild(newSendButton, sendButton);
        }
        
        // 添加新的点击事件
        newSendButton.addEventListener('click', function(e) {
            e.preventDefault();
            sendMessage();
        });
    }
    
    // 输入法开始编辑
    newUserInput.addEventListener('compositionstart', function(e) {
        console.log('输入法编辑开始');
        window.isIMEComposing = true;
    });
    
    // 输入法编辑中
    newUserInput.addEventListener('compositionupdate', function(e) {
        window.isIMEComposing = true;
    });
    
    // 输入法编辑结束
    newUserInput.addEventListener('compositionend', function(e) {
        console.log('输入法编辑结束');
        window.isIMEComposing = false;
        // 记录输入法编辑结束时间戳
        window.lastIMEEndTime = Date.now();
    });
    
    // 键盘按下事件
    newUserInput.addEventListener('keydown', function(e) {
        // 如果是回车键
        if (e.key === 'Enter' || e.keyCode === 13) {
            // 如果按住Shift键，允许换行
            if (e.shiftKey) {
                return true; // 允许默认行为
            }
            
            // 检查输入法状态
            if (window.isIMEComposing) {
                console.log('输入法编辑中，按回车转为英文而不发送消息');
                return true; // 允许输入法处理，自动转为英文
            }
            
            // 检查是否刚刚结束输入法编辑（50ms内）
            const now = Date.now();
            if (now - window.lastIMEEndTime < 50) {
                console.log('刚刚结束输入法编辑，可能是回车选择，不发送消息');
                return true;
            }
            
            // 添加额外检查，防止某些输入法状态未被正确捕获
            const inputValue = this.value;
            // 检查是否有未完成的拼音输入（包含空格且最后一个空格后面有内容）
            const hasPinyinInput = / [a-z]+$/.test(inputValue);
            
            if (hasPinyinInput) {
                console.log('检测到疑似拼音输入，不发送消息');
                return true; // 允许输入法处理
            }
            
            // 普通状态下按回车，发送消息
            console.log('发送消息...');
            e.preventDefault();
            e.stopPropagation();
            setTimeout(function() {
                sendMessage();
            }, 10);
            return false;
        }
    });
    
    // 自动调整输入框高度
    newUserInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });
    
    console.log('输入框事件监听器设置完成');
}

// 设置文件上传相关事件
function setupFileUpload() {
    const fileInput = document.getElementById('fileInput');
    const uploadButton = document.getElementById('uploadButton');
    
    // 确保元素存在
    if (!fileInput || !uploadButton) {
        console.error('文件上传元素未找到');
        return;
    }
    
    console.log('设置文件上传功能');
    
    // 添加上传按钮点击事件
    uploadButton.onclick = function(e) {
        e.preventDefault();
        console.log('上传按钮被点击');
        
        // 创建一个临时的文件输入框，这样可以避免清除现有的已选文件
        const tempFileInput = document.createElement('input');
        tempFileInput.type = 'file';
        tempFileInput.multiple = true;
        tempFileInput.accept = fileInput.accept;
        tempFileInput.style.display = 'none';
        document.body.appendChild(tempFileInput);
        
        // 监听文件选择
        tempFileInput.onchange = function() {
            if (this.files.length > 0) {
                // 使用handleFileSelection处理文件，它会合并文件而不是替换
                handleFileSelection(this.files);
            }
            // 移除临时输入框
            document.body.removeChild(tempFileInput);
        };
        
        // 触发文件选择
        tempFileInput.click();
    };
    
    // 直接在文件输入框上设置change事件，增加额外的保护
    fileInput.addEventListener('change', function(e) {
        // 这个事件可能永远不会触发，因为我们使用临时输入框，但保留以防万一
        if (this.files.length > 0) {
            console.log('文件输入框直接变化，选择了', this.files.length, '个文件');
            handleFileSelection(this.files);
        }
    });
    
    // 设置拖放功能
    setupDragAndDrop();
    
    console.log('文件上传功能设置完成');
}

// 设置拖放功能
function setupDragAndDrop() {
    const dropZone = document.querySelector('.input-wrapper');
    
    if (!dropZone) {
        console.error('拖放区域未找到');
        return;
    }
    
    console.log('设置文件拖放功能');
    
    // 防止默认拖放行为
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, function(e) {
            e.preventDefault();
            e.stopPropagation();
        }, false);
    });
    
    // 拖拽进入和悬停效果
    ['dragenter', 'dragover'].forEach(eventName => {
        dropZone.addEventListener(eventName, function() {
            dropZone.classList.add('drag-over');
        }, false);
    });
    
    // 拖拽离开和放下效果
    ['dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, function() {
            dropZone.classList.remove('drag-over');
        }, false);
    });
    
    // 处理文件放下
    dropZone.addEventListener('drop', function(e) {
        console.log('文件已拖放到输入框');
        if (e.dataTransfer.files.length > 0) {
            handleFileSelection(e.dataTransfer.files);
        }
    }, false);
    
    console.log('文件拖放功能设置完成');
}

// 处理文件选择
function handleFileSelection(newFiles) {
    if (!newFiles || newFiles.length === 0) return;
    
    console.log('新文件已选择:', newFiles.length, '个文件');
    
    const fileList = document.getElementById('fileList');
    
    // 获取当前已有的文件名列表，避免重复添加
    const existingFileNames = {};
    uploadedFiles.forEach(file => {
        existingFileNames[file.name] = true;
    });
    
    // 清空文件列表的UI显示
    fileList.innerHTML = '';
    
    // 处理每个新文件
    let newFilesAdded = 0;
    Array.from(newFiles).forEach(file => {
        // 检查文件类型和大小
        if (!isValidFile(file)) return;
        
        // 如果文件已经存在，替换它
        if (existingFileNames[file.name]) {
            console.log('替换已存在的文件:', file.name);
            // 从全局数组中移除同名文件
            const index = uploadedFiles.findIndex(f => f.name === file.name);
            if (index !== -1) {
                uploadedFiles.splice(index, 1);
            }
        }
        
        // 添加新文件到全局数组
        uploadedFiles.push(file);
        existingFileNames[file.name] = true;
        newFilesAdded++;
    });
    
    console.log('当前共有上传文件:', uploadedFiles.length, '个文件');
    
    // 重新显示所有文件（包括新的和原有的）
    uploadedFiles.forEach(file => {
        console.log('显示文件:', file.name, file.size, 'bytes');
        
        // 创建文件项
        const fileItem = createFileItem(file);
        fileList.appendChild(fileItem);
        
        // 如果是图片，添加预览缩略图
        if (file.type.startsWith('image/')) {
            addImagePreview(file, fileItem);
        }
    });
    
    // 确保文件列表可见
    if (fileList.children.length > 0) {
        fileList.style.display = 'flex';
        // 调整聊天消息区域的底部边距，为文件列表腾出空间
        document.querySelector('.chat-messages').style.paddingBottom = '250px';
        console.log('文件列表显示完成，包含', fileList.children.length, '个文件');
    } else {
        fileList.style.display = 'none';
        // 恢复聊天消息区域的底部边距
        document.querySelector('.chat-messages').style.paddingBottom = '120px';
        console.log('文件列表为空，不显示');
    }
    
    // 移除自动预览部分，只在用户点击文件时才预览
}

// 验证文件
function isValidFile(file) {
        const maxSize = 100 * 1024 * 1024; // 100MB
    
        if (file.size > maxSize) {
            alert('文件大小不能超过100MB');
        return false;
    }
    
    const allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'pdf', 'doc', 'docx', 'txt', 'csv', 'xls', 'xlsx', 'json', 'md', 'py', 'js', 'html', 'css', 'java', 'c', 'cpp', 'h', 'php', 'sql'];
    const fileExtension = file.name.split('.').pop().toLowerCase();
    
    if (!allowedExtensions.includes(fileExtension)) {
        alert('不支持的文件格式');
        return false;
    }
    
    console.log('文件验证通过:', file.name);
    return true;
}

// 创建文件项
function createFileItem(file) {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
    fileItem.dataset.filename = file.name; // 添加文件名属性
    fileItem.style.cursor = 'pointer'; // 添加指针样式，表明可点击
    
    // 格式化文件大小
    const fileSize = formatFileSize(file.size);
    
    // 获取文件扩展名
    const fileExt = file.name.split('.').pop().toLowerCase();
    
    // 创建文件图标
        let iconHtml = '';
    if (file.type.startsWith('image/')) {
        iconHtml = '<div class="file-icon-wrapper"><div class="file-icon image"><img src="" alt="预览"></div></div>';
        } else {
        iconHtml = `<div class="file-icon-wrapper ${fileExt}">
            ${getFileIconSvg(fileExt)}
        </div>`;
    }
    
    // 创建文件信息区域
    const fileInfoHtml = `
            <div class="file-info">
                <div class="file-name">${file.name}</div>
            <div class="file-size">${fileSize}</div>
            </div>
    `;
    
    // 创建移除按钮
    const removeButtonHtml = `
        <button class="remove-button" onclick="removeFileItem(this)" title="移除">
            <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="16" width="16">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        `;
        
    // 组合HTML
    fileItem.innerHTML = iconHtml + fileInfoHtml + removeButtonHtml;
    
    // 添加点击事件，打开预览功能
    fileItem.addEventListener('click', function(e) {
        // 阻止点击事件冒泡，以防移除按钮的点击触发预览
        if (e.target.closest('.remove-button')) {
            return;
        }
        // 调用预览函数
        previewFile(file.name, fileExt);
    });
    
    return fileItem;
}

// 添加图片预览
function addImagePreview(file, fileItem) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = fileItem.querySelector('.file-icon img');
        if (img) {
            img.src = e.target.result;
        }
    };
    reader.readAsDataURL(file);
}

// 格式化文件大小
function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
    else return (bytes / 1048576).toFixed(1) + ' MB';
}

// 移除文件项
function removeFileItem(button) {
    const fileItem = button.closest('.file-item');
    const fileList = document.getElementById('fileList');
    
    // 获取要删除的文件名
    const fileName = fileItem.querySelector('.file-name').textContent;
    
    console.log('正在删除文件:', fileName);
    
    // 从全局文件数组中移除文件
    const fileIndex = uploadedFiles.findIndex(file => file.name === fileName);
    if (fileIndex !== -1) {
        uploadedFiles.splice(fileIndex, 1);
        console.log('文件已从全局数组中移除:', fileName);
    }
    
    // 移除文件项
            fileItem.remove();
    
    // 如果没有文件了，隐藏预览容器
            if (fileList.children.length === 0) {
                fileList.style.display = 'none';
        // 恢复聊天消息区域的底部边距
        document.querySelector('.chat-messages').style.paddingBottom = '120px';
        console.log('文件列表已清空，隐藏文件预览区域');
    }
}

// 为了兼容性，将removeFile函数重定向到removeFileItem
function removeFile(button) {
    console.log('removeFile函数已被调用，重定向到removeFileItem');
    removeFileItem(button);
}

function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
}

function highlight() {
    document.querySelector('.input-wrapper').style.borderColor = 'var(--primary-color)';
    document.querySelector('.input-wrapper').style.background = 'rgba(16, 163, 127, 0.05)';
}

function unhighlight() {
    document.querySelector('.input-wrapper').style.borderColor = 'var(--border-color)';
    document.querySelector('.input-wrapper').style.background = 'transparent';
}

function handleDrop(e) {
    const dt = e.dataTransfer;
    const files = dt.files;
    handleFileSelection(files); // 使用handleFileSelection代替handleFiles
}

function handleFileSelect(e) {
    handleFileSelection(e.target.files);
}

function handleFiles(files) {
    console.log('handleFiles函数被调用，将重定向到handleFileSelection');
    handleFileSelection(files);
}

async function sendMessage() {
    // 重置历史加载标志，确保新回复会有打字机效果
    window.isLoadingHistory = false;
    const userInput = document.getElementById('userInput');
    const message = userInput.value.trim();
    const fileList = document.getElementById('fileList');
    
    // 如果没有消息且没有文件，则不执行
    if (!message && (!fileList || fileList.children.length === 0)) return;
    
    // 记录当前状态
    console.log("正在发送消息，文件列表状态:", fileList ? fileList.children.length : 0, "个文件");
    console.log("全局文件数组包含", uploadedFiles.length, "个文件");
    
    // 记录文件详情用于调试
    if (uploadedFiles.length > 0) {
        console.log("将发送以下文件:");
        uploadedFiles.forEach((file, index) => {
            console.log(`[${index}] ${file.name} (${file.size} bytes, ${file.type})`);
        });
    }
    
    // 添加用户消息
    let messageContent = message;
    if (fileList && fileList.children.length > 0) {
        const fileNames = Array.from(fileList.children).map(item => {
            const name = item.querySelector('.file-name').textContent;
            console.log(`添加文件到消息: "${name}"`);
            return name;
        }).join(', ');
        console.log(`最终文件名列表: "${fileNames}"`);
        messageContent += `\n[已上传文件：${fileNames}]`;
    }
    addMessage(messageContent, 'user');
    userInput.value = '';
    userInput.style.height = 'auto';

    // 显示加载状态
    const loadingMessage = addLoadingMessage();

    try {
        // 获取当前对话的所有消息
        const chatMessages = Array.from(document.querySelectorAll('.message')).map(msg => {
            const contentElement = msg.querySelector('.message-content');
            return {
                type: msg.classList.contains('user') ? 'user' : 'ai',
                content: contentElement ? contentElement.textContent.replace(/\n/g, ' ') : ''
            };
        });

        // 创建FormData对象
        const formData = new FormData();
        formData.append('message', message);
        // 确保排除当前正在发送的消息
        formData.append('history', JSON.stringify(chatMessages.slice(0, -1)));
        
        // 添加文件
        let filesAdded = 0;
        let hasFiles = false;
        if (uploadedFiles.length > 0) {
            hasFiles = true;
            console.log("准备添加文件到请求，总共有", uploadedFiles.length, "个文件");
            
            // 添加文件到FormData
            uploadedFiles.forEach(file => {
                formData.append('files[]', file);
                console.log('已添加文件到请求:', file.name, file.size, 'bytes');
                filesAdded++;
            });
        }
        
        console.log(`发送请求到服务器，总共添加了 ${filesAdded} 个文件`);
        
        const response = await fetch('/api/ai_analysis', {
            method: 'POST',
            body: formData
        });
        
        const data = await response.json();
        console.log("收到服务器响应:", data);
        
        // 移除加载消息
        loadingMessage.remove();
        
        if (data.success) {
            // 如果包含文件，添加提示信息
            if (hasFiles) {
                console.warn("提示：文件仅存储在当前浏览器会话中。如需重新生成回答，请勿刷新页面或重新上传相同文件。");
            }
            
            if (!data.response || data.response === 'API响应中没有找到有效的内容' || data.response.includes('API请求失败')) {
                const errorMsg = '抱歉，暂时无法处理您的请求，请稍后重试。';
                await new Promise(resolve => {
                    addMessage(errorMsg, 'ai', resolve); // 等待消息完全渲染
                });
                // 保存聊天记录（使用错误消息作为AI回复）
                await saveChat(message, errorMsg);
            } else {
                await new Promise(resolve => {
                    addMessage(data.response, 'ai', resolve); // 等待消息完全渲染
                });
                // 在这里添加标题生成函数调用
                // 生成并显示对话标题 - 确保这行代码被添加
                console.log("AI回复完成，尝试生成标题");
                generateAndDisplayTitle();
                // 保存聊天记录
                await saveChat(message, data.response);
            }
        } else {
            addMessage(`抱歉，处理您的请求时出现错误：${data.message}`, 'ai');
        }
        
        // 保留文件列表和已上传的文件，允许在同一对话中多次使用相同的文件
        
    } catch (error) {
        console.error('发送请求错误:', error);
        loadingMessage.remove();
        const errorMsg = '抱歉，服务器暂时无法处理您的请求。';
        await new Promise(resolve => {
            addMessage(errorMsg, 'ai', resolve); // 等待消息完全渲染
        });
        // 保存聊天记录（使用错误消息作为AI回复）
        await saveChat(message, errorMsg);
    }
}

// 生成并显示对话标题
function generateAndDisplayTitle() {
    console.log("尝试生成标题...");
    
    // 如果已经有标题显示，则不再生成
    if (document.getElementById('chatTitle').style.display !== 'none') {
        console.log("标题已存在，不再生成");
        return;
    }
    
    // 获取当前消息数量
    const allMessages = document.querySelectorAll('.message');
    console.log(`当前消息数量: ${allMessages.length}`);
    
    // 只有在前两条消息（一问一答）时生成标题
    if (allMessages.length !== 3) {
        console.log("消息数量不是3，不生成标题");
        return;
    }
    
    // 获取第一个用户问题内容
    const firstUserMessage = document.querySelector('.message.user');
    if (!firstUserMessage) {
        console.log("未找到用户消息");
        return;
    }
    
    const messageContent = firstUserMessage.querySelector('.message-content');
    if (!messageContent) {
        console.log("未找到消息内容元素");
        return;
    }
    
    let messageText = messageContent.textContent || messageContent.innerText;
    console.log(`提取到的消息文本: ${messageText.substring(0, 50)}...`);
    
    // 智能提取标题
    let title = extractTitle(messageText);
    console.log(`生成的标题: ${title}`);
    
    // 设置标题
    const titleElement = document.getElementById('chatTitleText');
    titleElement.textContent = title;
    
    // 显示标题元素
    const chatTitle = document.getElementById('chatTitle');
    chatTitle.style.display = 'block';
    
    // 添加动画效果
    setTimeout(() => {
        chatTitle.classList.add('animate');
    }, 100);
    
    // 保存标题到全局变量，便于后续使用
    window.currentChatTitle = title;
}

// 从用户问题中提取更智能的标题
function extractTitle(text) {
    // 移除多余空格
    text = text.trim();
    
    // ==================== 0. 文件和照片检测 ====================
    // 检测问题中是否包含文件或照片
    const filePatterns = {
        excel: /\.xlsx|\.xls|\.csv|excel文件|表格文件|数据表|电子表格/i,
        programming: /\.py|\.js|\.java|\.cpp|\.c|\.cs|\.php|\.rb|\.go|\.ts|\.html|\.css|代码文件|源代码|程序文件/i,
        document: /\.doc|\.docx|\.pdf|\.txt|\.md|文档|word文档|文本文件|markdown/i,
        image: /\.jpg|\.jpeg|\.png|\.gif|\.bmp|\.svg|图片|照片|截图|图像/i,
        presentation: /\.ppt|\.pptx|幻灯片|演示文稿|PPT/i,
        archive: /\.zip|\.rar|\.7z|\.tar|\.gz|压缩文件|压缩包/i,
        audio: /\.mp3|\.wav|\.ogg|\.flac|音频|音乐|声音文件/i,
        video: /\.mp4|\.avi|\.mov|\.wmv|视频|视频文件|录像/i
    };
    
    // 检测是否包含文件描述
    let detectedFileType = null;
    let fileTypeLabel = "";
    
    for (const [type, pattern] of Object.entries(filePatterns)) {
        if (pattern.test(text)) {
            detectedFileType = type;
            // 尝试提取文件扩展名或描述
            const match = text.match(pattern);
            if (match) {
                fileTypeLabel = match[0];
            }
            
            // 根据文件类型设置更友好的标签
            switch(type) {
                case 'excel': fileTypeLabel = fileTypeLabel.includes('.') ? 'Excel文件' : fileTypeLabel; break;
                case 'programming': fileTypeLabel = fileTypeLabel.includes('.') ? '代码文件' : fileTypeLabel; break;
                case 'document': fileTypeLabel = fileTypeLabel.includes('.') ? '文档文件' : fileTypeLabel; break;
                case 'image': fileTypeLabel = fileTypeLabel.includes('.') ? '图片文件' : fileTypeLabel; break;
                case 'presentation': fileTypeLabel = fileTypeLabel.includes('.') ? 'PPT文件' : fileTypeLabel; break;
                case 'archive': fileTypeLabel = fileTypeLabel.includes('.') ? '压缩文件' : fileTypeLabel; break;
                case 'audio': fileTypeLabel = fileTypeLabel.includes('.') ? '音频文件' : fileTypeLabel; break;
                case 'video': fileTypeLabel = fileTypeLabel.includes('.') ? '视频文件' : fileTypeLabel; break;
            }
        }
    }
    
    // 额外检测是否提到了"文件"或"附件"关键词
    const hasFileKeywords = /文件|附件|上传|传输|发送了|附带|附加|attached|uploaded/i.test(text);
    
    // 检测是否包含多个文件
    const hasMultipleFiles = /多个|几个|一些|多份|several|multiple|various/i.test(text) && hasFileKeywords;
    
    // 针对文件的操作描述
    const fileOperations = {
        analysis: /分析|解析|处理|统计|汇总|计算|可视化|分类|归类|整理/i,
        extraction: /提取|抽取|导出|获取|检索|查找/i,
        conversion: /转换|转化|导入|迁移|格式转换|转成|转为/i,
        improvement: /优化|改进|修复|调整|美化|增强|完善/i,
        creation: /创建|生成|制作|编写|写一个|设计|开发/i,
        comparison: /比较|对比|对照|差异|比对/i
    };
    
    // 检测文件操作类型
    let fileOperation = null;
    for (const [op, pattern] of Object.entries(fileOperations)) {
        if (pattern.test(text)) {
            fileOperation = op;
            break;
        }
    }
    
    // 如果检测到文件相关内容，生成文件处理相关标题
    if (detectedFileType || (hasFileKeywords && fileOperation)) {
        // 提取文件处理的对象/内容
        let contentMatch = null;
        
        // 基于文件类型构建更精细的内容提取模式
        if (detectedFileType) {
            const extractPatterns = {
                excel: [
                    /分析(.{2,20})的(数据|表格|excel|电子表格)/i,
                    /(数据|表格|excel|电子表格)中(.{2,20})的分析/i,
                    /提取(.{2,20})的(数据|信息|内容)/i
                ],
                programming: [
                    /实现(.{2,20})的(功能|算法|代码|程序)/i,
                    /(优化|修复|调试)(.{2,20})的(代码|程序|函数)/i,
                    /(代码|程序)实现(.{2,20})/i
                ],
                document: [
                    /提取(.{2,20})的(内容|信息|要点)/i,
                    /分析(.{2,20})的(文档|文本|内容)/i,
                    /(总结|概括)(.{2,20})的(要点|内容)/i
                ],
                image: [
                    /识别(.{2,20})的(内容|对象|文字)/i,
                    /分析(.{2,20})的(图像|图片|照片)/i,
                    /(处理|修复|增强)(.{2,20})的(图像|图片|照片)/i
                ]
            };
            
            const patterns = extractPatterns[detectedFileType] || [];
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match && match[1]) {
                    contentMatch = match[1].trim();
                    if (match[2]) {
                        contentMatch = `${contentMatch}的${match[2].trim()}`;
                    }
                    break;
                }
            }
        }
        
        // 如果没有匹配到具体内容，尝试提取跟在操作词后面的内容
        if (!contentMatch && fileOperation) {
            const opWords = fileOperations[fileOperation].source.replace(/[\/\|\(\)\[\]\{\}\^\$\+\*\?\.\\\-]/g, '').split('|');
            for (const word of opWords) {
                if (text.includes(word)) {
                    const afterOp = text.substring(text.indexOf(word) + word.length, text.indexOf(word) + word.length + 30).trim();
                    if (afterOp && afterOp.length > 2) {
                        contentMatch = afterOp.replace(/[?？!！.。,，:：;；].*$/g, '');
                        break;
                    }
                }
            }
        }
        
        // 构建文件处理标题
        let fileTitle = '';
        
        // 根据文件操作类型生成动作描述
        let actionDesc = '';
        switch(fileOperation) {
            case 'analysis': actionDesc = '分析'; break;
            case 'extraction': actionDesc = '提取'; break;
            case 'conversion': actionDesc = '转换'; break;
            case 'improvement': actionDesc = '优化'; break;
            case 'creation': actionDesc = '创建'; break;
            case 'comparison': actionDesc = '比较'; break;
            default: actionDesc = '处理';
        }
        
        // 构建完整标题
        if (contentMatch) {
            // 有明确内容对象
            fileTitle = `${fileTypeLabel}${actionDesc}：${contentMatch}`;
        } else if (hasMultipleFiles) {
            // 多个文件但没具体内容
            fileTitle = `多个${fileTypeLabel}${actionDesc}`;
        } else {
            // 单个文件没具体内容
            fileTitle = `${fileTypeLabel}${actionDesc}`;
        }
        
        // 如果能识别出标题，直接返回
        if (fileTitle) {
            return fileTitle;
        }
    }
    
    // ==================== 1. 领域识别 ====================
    const domains = {
        // 技术与编程
        programming: {
            pattern: /代码|编程|函数|算法|开发|调试|程序|脚本|编写|实现|API|后端|前端|全栈|框架|库|软件|应用/i,
            label: "编程问题",
            languages: /Python|Java|JavaScript|C\+\+|C#|PHP|Ruby|Swift|Kotlin|Go|Rust|Matlab|R|Perl|Shell|TypeScript|SQL/i,
            frameworks: /React|Vue|Angular|Django|Flask|Spring|Laravel|Express|TensorFlow|PyTorch|Pandas|NumPy|Bootstrap/i,
            databases: /MySQL|PostgreSQL|MongoDB|SQLite|Oracle|Redis|Cassandra|MariaDB|Firebase/i
        },
        
        // 数据与分析
        data: {
            pattern: /数据分析|统计分析|excel|数据可视化|图表|数据处理|数据挖掘|数据预测|大数据|机器学习|人工智能|深度学习|神经网络|自然语言处理/i,
            label: "数据分析",
            tools: /Excel|Tableau|Power BI|SPSS|SAS|R|Python|Pandas|NumPy|Matplotlib|Seaborn|TensorFlow|PyTorch|Hadoop|Spark/i
        },
        
        // 设计与创意
        design: {
            pattern: /设计|UI|UX|界面|交互|用户体验|原型|样式|布局|响应式|创意|艺术|绘画|作品|插画|海报|logo|配色|字体|平面设计/i,
            label: "设计创意",
            tools: /Photoshop|Illustrator|Sketch|Figma|InDesign|XD|After Effects|Premiere|Canva|Procreate/i
        },
        
        // 商业与市场
        business: {
            pattern: /营销|销售|客户|用户|产品|市场|运营|增长|转化率|KPI|ROI|商业模式|创业|电商|广告|品牌|定价|推广|竞品分析|商业计划/i,
            label: "商业营销",
            domains: /B2B|B2C|C2C|O2O|DTC|SaaS|电商|跨境|零售|批发|品牌|独立站/i
        },
        
        // 教育与学习
        education: {
            pattern: /学习|教育|教学|课程|培训|知识|技能|学校|大学|考试|考研|考公|备考|论文|作业|习题|学位|专业|学科|辅导|教材/i,
            label: "教育学习",
            subjects: /语文|数学|英语|物理|化学|生物|历史|地理|政治|经济|哲学|文学|计算机科学|工程学|医学|法学|管理学|艺术学/i
        },
        
        // 职场与就业
        career: {
            pattern: /职场|工作|就业|求职|简历|面试|招聘|薪资|晋升|职业规划|办公|同事|上司|员工|HR|人力资源|职业发展|跳槽|入职|离职/i,
            label: "职场就业",
            positions: /工程师|设计师|产品经理|运营|市场|销售|客服|HR|总监|经理|CEO|CTO|CFO|COO/i
        },
        
        // 健康与医疗
        health: {
            pattern: /健康|医疗|疾病|症状|治疗|医院|医生|药物|营养|饮食|锻炼|健身|瑜伽|减肥|睡眠|心理健康|抑郁|焦虑|压力|医保/i,
            label: "健康医疗",
            subjects: /内科|外科|妇科|儿科|眼科|耳鼻喉科|皮肤科|精神科|心理学|营养学|中医|西医|临床|护理/i
        },
        
        // 生活与家居
        lifestyle: {
            pattern: /生活|家居|装修|厨房|做饭|菜谱|美食|家具|家电|清洁|收纳|养花|养宠|养娃|育儿|婚恋|旅游|摄影|音乐|阅读|电影/i,
            label: "生活家居",
            topics: /装修|做饭|旅游|养娃|购物|家电|家具|时尚|穿搭|美妆|护肤|追剧|读书|拍照|结婚|恋爱|约会/i
        },
        
        // 金融与投资
        finance: {
            pattern: /金融|投资|理财|股票|基金|债券|保险|银行|信用卡|贷款|房贷|车贷|资产|负债|税务|财务|会计|审计|报表|报税/i,
            label: "金融投资",
            markets: /股市|楼市|债市|汇市|期货|数字货币|外汇|大宗商品|ETF|指数|新三板|创业板|主板/i
        },
        
        // 法律与政策
        legal: {
            pattern: /法律|政策|法规|条例|合同|协议|知识产权|专利|商标|版权|诉讼|仲裁|劳动法|合同法|公司法|婚姻法|继承法|刑法|民法/i,
            label: "法律政策",
            fields: /知识产权|商业法|劳动法|婚姻法|房产法|刑法|民法|合同法|公司法|证券法|税法/i
        },
        
        // 科学与研究
        science: {
            pattern: /科学|研究|实验|观察|假设|证明|理论|物理|化学|生物|数学|天文|地理|地质|环境|生态|气候|材料|能源|宇宙/i,
            label: "科学研究",
            fields: /物理学|化学|生物学|数学|天文学|地质学|环境科学|材料科学|能源科学|计算机科学|社会科学|人文科学/i
        }
    };
    
    // 检测领域和特定专业术语
    let detectedDomain = null;
    let domainSpecificTerm = null;
    
    for (const [domain, data] of Object.entries(domains)) {
        if (data.pattern.test(text)) {
            detectedDomain = {domain, ...data};
            
            // 检测专业术语
            for (const [termType, pattern] of Object.entries(data)) {
                if (termType !== 'pattern' && termType !== 'label') {
                    const match = text.match(pattern);
                    if (match) {
                        domainSpecificTerm = match[0];
                        break;
                    }
                }
            }
            break;
        }
    }
    
    // 设置问题类型标签
    let domainLabel = "一般问题";
    if (detectedDomain) {
        domainLabel = domainSpecificTerm ? `${domainSpecificTerm}${detectedDomain.label}` : detectedDomain.label;
    }
    
    // ==================== 2. 特定领域处理模式 ====================
    
    // 编程问题特殊处理
    if (detectedDomain && detectedDomain.domain === 'programming') {
        const codingPatterns = [
            {pattern: /用(\w+)写[几个]*(.{3,30})/, template: (lang, task) => `${lang}编程：${task}`},
            {pattern: /用(\w+)实现[几个]*(.{3,30})/, template: (lang, task) => `${lang}实现：${task}`},
            {pattern: /使用(\w+)开发(.{3,30})/, template: (lang, task) => `${lang}开发：${task}`},
            {pattern: /如何[在用](\w+)[中]*(.{3,30})/, template: (lang, task) => `${lang}指南：${task}`},
            {pattern: /(\w+)[的]*代码[来]*(.{3,30})/, template: (lang, task) => `${lang}代码：${task}`}
        ];
        
        for (const {pattern, template} of codingPatterns) {
            const match = text.match(pattern);
            if (match && match[1] && match[2]) {
                let lang = match[1].trim();
                let task = match[2].trim().replace(/[?？!！.。,，:：;；]|的代码$|的程序$|的实现$/g, '');
                
                // 检查提取的是否是编程语言
                if (detectedDomain.languages.test(lang)) {
                    return template(lang, task);
                }
            }
        }
    }
    
    // 数据分析特殊处理
    if (detectedDomain && detectedDomain.domain === 'data') {
        const dataPatterns = [
            {pattern: /如何[分析处理](.{3,30})数据/, template: task => `数据分析：${task}数据`},
            {pattern: /(.{3,20})数据[分析处理]/, template: subject => `${subject}数据分析`},
            {pattern: /用(Excel|Tableau|Power BI|SPSS)(.{3,30})/, template: (tool, task) => `${tool}${task}`}
        ];
        
        for (const {pattern, template} of dataPatterns) {
            const match = text.match(pattern);
            if (match && match[1]) {
                let param1 = match[1].trim();
                let param2 = match[2] ? match[2].trim() : '';
                return template(param1, param2);
            }
        }
    }
    
    // 金融投资特殊处理
    if (detectedDomain && detectedDomain.domain === 'finance') {
        const financePatterns = [
            {pattern: /如何投资(.{3,20})/, template: asset => `投资指南：${asset}`},
            {pattern: /(.{3,20})股票分析/, template: stock => `股票分析：${stock}`},
            {pattern: /(.{3,20})基金推荐/, template: () => `基金推荐`}
        ];
        
        for (const {pattern, template} of financePatterns) {
            const match = text.match(pattern);
            if (match && match[1]) {
                return template(match[1].trim());
            }
        }
    }
    
    // ==================== 3. 通用问题模式识别 ====================
    const questionPatterns = [
        // 询问类模式
        {pattern: /如何(\S{3,40})/, template: subject => `如何${subject}`},
        {pattern: /怎样(\S{3,40})/, template: subject => `怎样${subject}`},
        {pattern: /怎么[才能够]*(\S{3,40})/, template: subject => `怎么${subject}`},
        {pattern: /用什么方法(.{3,40})/, template: subject => `方法：${subject}`},
        
        // 解释类模式
        {pattern: /什么是(\S{3,40})/, template: subject => `什么是${subject}`},
        {pattern: /(\S{3,30})是什么/, template: subject => `${subject}是什么`},
        {pattern: /解释一下(.{3,40})/, template: subject => `解释：${subject}`},
        
        // 比较类模式
        {pattern: /(.{2,15})和(.{2,15})的[区别差异比较]/, template: (a, b) => `比较：${a}和${b}`},
        {pattern: /(.{2,15})与(.{2,15})的[区别差异比较]/, template: (a, b) => `比较：${a}与${b}`},
        
        // 列举类模式
        {pattern: /有哪些(.{3,40})/, template: subject => `列举：${subject}`},
        {pattern: /推荐(.{3,40})/, template: subject => `推荐：${subject}`},
        
        // 原因类模式
        {pattern: /为什么(.{3,40})/, template: subject => `为什么${subject}`},
        {pattern: /原因(.{3,40})/, template: subject => `原因：${subject}`},
        
        // 请求帮助类模式
        {pattern: /帮[我助](.{3,40})/, template: subject => `帮助：${subject}`},
        {pattern: /请[教问](.{3,40})/, template: subject => `咨询：${subject}`}
    ];
    
    for (const {pattern, template} of questionPatterns) {
        const match = text.match(pattern);
        if (match) {
            if (match[2]) { // 有两个捕获组
                const a = match[1].trim().replace(/[?？!！.。,，:：;；]/g, '');
                const b = match[2].trim().replace(/[?？!！.。,，:：;；]/g, '');
                return `${domainLabel}：${template(a, b)}`;
            } else if (match[1]) { // 只有一个捕获组
                const subject = match[1].trim().replace(/[?？!！.。,，:：;；]/g, '');
                // 如果主题太长，进一步截取
                const shortSubject = subject.length > 30 ? subject.substring(0, 30) + "..." : subject;
                return `${domainLabel}：${template(shortSubject)}`;
            }
        }
    }
    
    // ==================== 4. 智能内容提取 ====================
    // 尝试提取第一句话
    const sentences = text.split(/[.!?。！？]/);
    if (sentences[0] && sentences[0].length >= 5 && sentences[0].length <= 50) {
        return `${domainLabel}：${sentences[0].trim()}`;
    }
    
    // 尝试按照冒号拆分
    if (text.includes("：") || text.includes(":")) {
        const parts = text.split(/：|:/);
        if (parts[1] && parts[1].trim().length < 50) {
            return `${domainLabel}：${parts[1].trim()}`;
        }
    }
    
    // 关键词提取（简化版）
    if (text.length > 40) {
        // 移除常见的引导词
        const cleanedText = text.replace(/^(请问|请|我想问|我想知道|我需要|我想|问一下|有个问题)/i, '');
        
        // 尝试提取关键操作和对象
        const commonOperations = ["分析", "计算", "处理", "设计", "实现", "解决", "比较", "提高", "降低", "优化", "改善"];
        
        for (const op of commonOperations) {
            if (cleanedText.includes(op)) {
                const index = cleanedText.indexOf(op) + op.length;
                const afterOp = cleanedText.substring(index, index + 25).trim();
                if (afterOp && afterOp.length > 2) {
                    return `${domainLabel}：${op}${afterOp.replace(/[?？!！.。,，:：;；].*$/g, '')}`;
                }
            }
        }
        
        // 如果没有找到明确操作，截取清理后的文本
        return `${domainLabel}：${cleanedText.substring(0, 40)}${cleanedText.length > 40 ? "..." : ""}`;
    }
    
    // 如果文本较短，直接使用原文
    return text.length <= 40 ? text : `${domainLabel}：${text.substring(0, 40)}...`;
}

// 获取特定对话的历史记录
async function getChatHistory(chatId) {
    try {
        const response = await fetch('/api/chat_history', {
            credentials: 'same-origin'  // 添加这一行，确保cookie被正确发送
        });
        const data = await response.json();
        
        if (data.success) {
            return data.chats.find(c => c.id === chatId);
        }
        return null;
    } catch (error) {
        return null;
    }
}

// 保存聊天记录
async function saveChat(message, aiResponse) {
    try {
        // 检查是否有活跃的对话
        const activeChat = document.querySelector('.history-item.active');
        
        // 获取所有消息的HTML内容和结构信息
            const chatMessages = Array.from(document.querySelectorAll('.message')).map(msg => {
            const contentElement = msg.querySelector('.message-content');
            // 保存innerHTML而不是textContent，以保留格式
            let rawContent = contentElement ? contentElement.innerHTML : '';
            
            // 检查是否有附件文件
            let attachedFiles = msg.dataset.attachedFiles || '';
            
            // 只保存必要的类名
            let type = msg.classList.contains('user') ? 'user' : 
                      msg.classList.contains('ai') ? 'ai' : 'system';
            
            return {
                type: type,
                content: rawContent,
                attachedFiles: attachedFiles,
                timestamp: new Date().toISOString()
            };
        });
            
        // 检查文件列表
        const filesList = Array.from(document.querySelectorAll('.message-files')).map(filesContainer => {
            return {
                files: Array.from(filesContainer.querySelectorAll('.file-item, .message-file')).map(item => {
                    const nameElement = item.querySelector('.file-name');
                    return {
                        name: nameElement ? nameElement.textContent : item.dataset.filename || '',
                        type: item.dataset.fileType || ''
                    };
                })
            };
        });
        
        // 保存结构化数据，包含HTML
        const completeChat = {
            title: window.currentChatTitle || '',
            messages: chatMessages,
            files: filesList
        };
        
        if (activeChat) {
            // 如果有活跃对话，更新现有对话
            const chatId = activeChat.dataset.id;
            await updateExistingChat(chatId, JSON.stringify(completeChat));
        } else {
            // 如果没有活跃对话，创建新对话
            const response = await fetch('/api/chat_history', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'same-origin',
                body: JSON.stringify({
                    title: message.substring(0, 50) + (message.length > 50 ? '...' : ''),
                    message: JSON.stringify(completeChat)
                })
            });
            
            const data = await response.json();
            if (data.success) {
                // 更新历史记录列表
                await updateHistoryList();
                // 移除所有对话的活跃状态
                const historyItems = document.querySelectorAll('.history-item');
                historyItems.forEach(item => item.classList.remove('active'));
                // 获取新创建的对话并设置为活跃
                const newChat = document.querySelector('.history-item:first-child');
                if (newChat) {
                    newChat.classList.add('active');
                }
            }
        }
    } catch (error) {
    }
}

// 更新历史记录列表
async function updateHistoryList() {
    try {
        const response = await fetch('/api/chat_history', {
            credentials: 'same-origin'
        });
        
        if (response.status === 302 || response.status === 401) {
            // 如果是未登录或会话过期，显示提示并刷新页面
            alert('登录已过期，请重新登录');
            window.location.href = '/login';
            return;
        }
        
        const data = await response.json();
        
        const historyList = document.querySelector('.history-list');
        historyList.style.display = 'block';
        historyList.innerHTML = '';
        
        if (data.success && data.chats && data.chats.length > 0) {
            // 排序：最新的对话在上面
            data.chats.sort((a, b) => new Date(b.timestamp || 0) - new Date(a.timestamp || 0));
            
            data.chats.forEach(chat => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                historyItem.dataset.id = chat.id;
                
                // 如果是当前活跃对话，添加活跃类
                const activeChat = document.querySelector('.history-item.active');
                if (activeChat && activeChat.dataset.id === chat.id) {
                    historyItem.classList.add('active');
                }
                
                // 创建标题和内容 div
                const contentDiv = document.createElement('div');
                contentDiv.className = 'content';
                
                // 创建标题 div 包含图标和标题文本
                const titleDiv = document.createElement('div');
                titleDiv.className = 'history-title';
                
                // 聊天图标
                titleDiv.innerHTML = `
                    <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                                </svg>
                `;
                
                // 解析消息格式以获取更好的标题
                let title = chat.title || "对话";
                try {
                    // 尝试解析为新格式
                    const chatData = JSON.parse(chat.message);
                    if (chatData.messages && Array.isArray(chatData.messages)) {
                        // 新格式：从第一条用户消息中提取标题
                        const firstUserMsg = chatData.messages.find(m => m.type === 'user');
                        if (firstUserMsg) {
                            title = firstUserMsg.content.substring(0, 50) + (firstUserMsg.content.length > 50 ? '...' : '');
                        }
                    } else if (Array.isArray(chatData)) {
                        // 旧格式：从第一条消息中提取标题
                        const firstMsg = chatData.find(m => m.type === 'user');
                        if (firstMsg) {
                            title = firstMsg.content.substring(0, 50) + (firstMsg.content.length > 50 ? '...' : '');
                        }
                    }
                } catch (e) {
                }
                
                // 添加标题文本
                const titleText = document.createElement('span');
                titleText.textContent = title;
                titleDiv.appendChild(titleText);
                
                // 创建日期 div
                const dateDiv = document.createElement('div');
                dateDiv.className = 'history-date';
                
                // 格式化日期为相对时间
                const createdDate = new Date(chat.timestamp);
                dateDiv.textContent = formatRelativeTime(createdDate);
                
                // 将标题和日期添加到内容 div
                contentDiv.appendChild(titleDiv);
                contentDiv.appendChild(dateDiv);
                
                // 创建删除按钮
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.title = '删除此对话';
                deleteBtn.innerHTML = `
                    <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                                <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"></path>
                        <line x1="10" y1="11" x2="10" y2="17"></line>
                        <line x1="14" y1="11" x2="14" y2="17"></line>
                            </svg>
                `;
                
                // 删除按钮事件处理
                deleteBtn.addEventListener('click', async (e) => {
                    e.stopPropagation(); // 阻止事件冒泡到历史项的点击事件
                    
                    if (confirm('确定要删除这个对话吗？此操作不可撤销。')) {
                        try {
                            await deleteChat(chat.id);
                            historyItem.remove();
                            
                            // 如果删除的是当前活跃对话，清空对话区域并创建新对话
                            if (historyItem.classList.contains('active')) {
                                clearChat();
                            }
                            
                            // 如果没有历史记录了，显示无历史记录提示
                            const remainingItems = document.querySelectorAll('.history-item');
                            if (remainingItems.length === 0) {
                                const noHistoryDiv = document.createElement('div');
                                noHistoryDiv.className = 'no-history';
                                noHistoryDiv.textContent = '暂无历史对话记录';
                                historyList.appendChild(noHistoryDiv);
                            }
                        } catch (error) {
                            alert('删除聊天记录失败，请重试');
                        }
                    }
                });
                
                // 历史项点击事件处理
                historyItem.addEventListener('click', () => {
                    loadChat(chat.id);
                });
                
                // 把所有元素添加到历史项
                historyItem.appendChild(contentDiv);
                historyItem.appendChild(deleteBtn);
                
                // 将历史项添加到历史列表
                historyList.appendChild(historyItem);
            });
        } else {
            const noHistoryDiv = document.createElement('div');
            noHistoryDiv.className = 'no-history';
            noHistoryDiv.textContent = '暂无历史对话记录';
            historyList.appendChild(noHistoryDiv);
        }
    } catch (error) {
        const historyList = document.querySelector('.history-list');
        historyList.innerHTML = `<div class="no-history">加载历史记录失败</div>`;
    }
}

// 格式化相对时间
function formatRelativeTime(date) {
    // 确保date是有效的日期对象
    if (!(date instanceof Date) || isNaN(date.getTime())) {
        // 如果是字符串格式，尝试将其转换为日期对象
        if (typeof date === 'string') {
            try {
                // 兼容YYYY-MM-DD HH:MM:SS格式
                if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(date)) {
                    // 将YYYY-MM-DD HH:MM:SS转换为YYYY/MM/DD HH:MM:SS格式
                    // 因为某些浏览器可能不支持破折号分隔的日期格式
                    const reformattedDate = date.replace(/-/g, '/');
                    date = new Date(reformattedDate);
                } else {
                    // 尝试常规转换
                    date = new Date(date);
                }
                
                // 再次检查转换后的日期是否有效
                if (isNaN(date.getTime())) {
                    return '未知时间';
                }
            } catch (e) {
                console.error('日期转换失败:', e);
                return '未知时间';
            }
        } else {
            // 如果不是字符串，也不是有效日期对象，返回默认值
            return '未知时间';
        }
    }
    
    // 时区调整：在日期上加上8小时
    const adjustedDate = new Date(date.getTime() + 8 * 60 * 60 * 1000);
    
    const now = new Date();
    
    // 如果调整后的日期仍比当前时间晚（未来日期），使用绝对时间格式显示
    if (adjustedDate > now) {
        // 使用绝对时间格式化显示
        return adjustedDate.toLocaleDateString('zh-CN', {
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }
    
    const diffSeconds = Math.floor((now - adjustedDate) / 1000);
    
    if (diffSeconds < 60) {
        return '刚刚';
    }
    
    const diffMinutes = Math.floor(diffSeconds / 60);
    if (diffMinutes < 60) {
        return `${diffMinutes} 分钟前`;
    }
    
    const diffHours = Math.floor(diffMinutes / 60);
    if (diffHours < 24) {
        return `${diffHours} 小时前`;
    }
    
    const diffDays = Math.floor(diffHours / 24);
    if (diffDays < 30) {
        return `${diffDays} 天前`;
    }
    
    const diffMonths = Math.floor(diffDays / 30);
    if (diffMonths < 12) {
        return `${diffMonths} 个月前`;
    }
    
    const diffYears = Math.floor(diffMonths / 12);
    return `${diffYears} 年前`;
}

async function loadChat(chatId) {
    try {
        // 检查全局变量，用于标记是否正在加载历史记录
        window.isLoadingHistory = true;
        
        const response = await fetch('/api/chat_history', {
            credentials: 'same-origin'
        });
        
        if (response.status === 302 || response.status === 401) {
            alert('登录已过期，请重新登录');
            window.location.href = '/login';
            return;
        }
        
        const data = await response.json();
        
        if (data.success) {
            const chat = data.chats.find(c => c.id === chatId);
            if (chat) {
                // 清空当前对话
                const chatMessages = document.getElementById('chatMessages');
                chatMessages.innerHTML = '';
                
                try {
                    // 解析消息数据
                    const chatData = JSON.parse(chat.message);
                    
                    // 检查是否是新格式（包含messages和files属性）
                    if (chatData.messages && Array.isArray(chatData.messages)) {
                        // 恢复标题（如果有）
                        if (chatData.title) {
                            const titleElement = document.getElementById('chatTitleText');
                            titleElement.textContent = chatData.title;
                            const chatTitle = document.getElementById('chatTitle');
                            chatTitle.style.display = 'block';
                            chatTitle.classList.add('animate');
                            window.currentChatTitle = chatData.title;
                        } else {
                            // 如果没有保存的标题，隐藏标题区域
                            document.getElementById('chatTitle').style.display = 'none';
                        }

                        // 完全重建每条消息的DOM
                        chatData.messages.forEach(msg => {
                            // 使用addMessage或addFormattedMessage重建消息
                            if (msg.type === 'user' || msg.type === 'ai') {
                                // 传递isHtml=true参数，表示内容已包含HTML格式
                                addMessage(msg.content, msg.type, () => {}, null, true);
                                
                                // 只添加no-typewriter类到最后添加的消息（AI消息），保留走马灯效果
                            if (msg.type === 'ai') {
                                    const lastMessage = chatMessages.lastElementChild;
                                    if (lastMessage) {
                                        lastMessage.classList.add('no-typewriter');
                                        // 不添加no-carousel类，保留走马灯效果
                                    }
                                }
                            }
                        });
                        
                        // 处理文件列表（如果有）
                        if (chatData.files && chatData.files.length > 0) {
                            // 文件处理保持不变...
                        }
                    } else if (Array.isArray(chatData)) {
                        // 兼容旧格式
                        chatData.forEach(msg => {
                            // 传递isHtml=true参数，表示内容已包含HTML格式
                            addMessage(msg.content, msg.type, () => {}, null, true);
                            
                            // 只添加no-typewriter类到最后添加的消息（AI消息），保留走马灯效果
                            if (msg.type === 'ai') {
                                const lastMessage = chatMessages.lastElementChild;
                                if (lastMessage) {
                                    lastMessage.classList.add('no-typewriter');
                                    // 不添加no-carousel类，保留走马灯效果
                                }
                            }
                        });
                    } else {
                        throw new Error('未知的对话格式');
                    }
                } catch (e) {
                    if (chat.message) {
                        addMessage(chat.message, 'user', () => {}, null, false);
                    }
                    if (chat.response) {
                        addMessage(chat.response, 'ai', () => {}, null, false);
                        // 只添加no-typewriter类到最后添加的消息（AI消息），保留走马灯效果
                        const lastMessage = chatMessages.lastElementChild;
                        if (lastMessage) {
                            lastMessage.classList.add('no-typewriter');
                            // 不添加no-carousel类，保留走马灯效果
                        }
                    }
                }
                
                // 清空输入框和文件列表
                document.getElementById('userInput').value = '';
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';
                fileList.style.display = 'none';
                
                // 清空全局文件数组
                uploadedFiles.length = 0;
                
                // 恢复聊天消息区域的底部边距
                document.querySelector('.chat-messages').style.paddingBottom = '120px';
                
                // 高亮当前选中的对话
                const historyItems = document.querySelectorAll('.history-item');
                historyItems.forEach(item => item.classList.remove('active'));
                const currentItem = document.querySelector(`.history-item[data-id="${chatId}"]`);
                if (currentItem) {
                    currentItem.classList.add('active');
                }
                
                // 滚动到底部
                const messagesContainer = document.querySelector('.chat-messages');
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }
    } catch (error) {
    } finally {
        // 重置全局变量
        window.isLoadingHistory = false;
    }
}

// 更新现有对话
async function updateExistingChat(chatId, messages) {
    try {
        const response = await fetch(`/api/chat_history/${chatId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                message: messages
            })
        });
        
        const data = await response.json();
        if (data.success) {
            // 更新历史记录列表
            await updateHistoryList();
        }
    } catch (error) {
    }
}

// 为每个用户问题创建一个映射，存储所有AI回答的版本
const responseVersionsMap = new Map();

// 为每个用户问题创建一个映射，存储所有用户消息的版本
const userMessageVersionsMap = new Map();

// 添加消息版本跟踪
function addMessageVersion(userMessageId, aiResponse, userMessage = null, isNewVersion = true) {
    // 处理AI回答的版本
    if (!responseVersionsMap.has(userMessageId)) {
        responseVersionsMap.set(userMessageId, {
            versions: [aiResponse],
            currentVersion: 0
        });
    } else if (isNewVersion) {
        const versionData = responseVersionsMap.get(userMessageId);
        versionData.versions.push(aiResponse);
        versionData.currentVersion = versionData.versions.length - 1;
    }
    
    // 处理用户消息的版本
    if (userMessage && isNewVersion) {
        if (!userMessageVersionsMap.has(userMessageId)) {
            userMessageVersionsMap.set(userMessageId, {
                versions: [userMessage],
                currentVersion: 0
            });
        } else {
            const userVersionData = userMessageVersionsMap.get(userMessageId);
            userVersionData.versions.push(userMessage);
            userVersionData.currentVersion = userVersionData.versions.length - 1;
        }
    }
    
    return responseVersionsMap.get(userMessageId);
}

// 获取用户消息的唯一ID
function getUserMessageId(messageElement) {
    // 首先检查消息是否有responseFor属性
    if (messageElement.dataset.responseFor) {
        return messageElement.dataset.responseFor;
    }
    
    // 如果没有，尝试查找前一个用户消息
    const userMessage = messageElement.previousElementSibling;
    if (!userMessage || !userMessage.classList.contains('user')) {
        
        // 尝试向前查找最近的用户消息
        let currentElement = messageElement;
        for (let i = 0; i < 5; i++) {
            currentElement = currentElement.previousElementSibling;
            if (!currentElement) break;
            
            if (currentElement.classList.contains('user')) {
                
                // 确保它有ID
                if (!currentElement.dataset.messageId) {
                    currentElement.dataset.messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                }
                
                // 设置关联，方便后续查找
                messageElement.dataset.responseFor = currentElement.dataset.messageId;
                
                return currentElement.dataset.messageId;
            }
        }
        
        return null;
    }
    
    // 如果消息没有ID，生成一个
    if (!userMessage.dataset.messageId) {
        userMessage.dataset.messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    // 设置关联，方便后续查找
    messageElement.dataset.responseFor = userMessage.dataset.messageId;
    
    return userMessage.dataset.messageId;
}

// 更新版本导航UI
function updateVersionNavigation(messageElement, versionData) {
    // 移除旧的导航（如果存在）
    let oldNav = messageElement.querySelector('.response-versions-nav');
    if (oldNav) {
        oldNav.remove();
    }
    
    // 如果只有一个版本且不是强制显示，不显示导航
    if (versionData.versions.length <= 1 && !versionData.forceShow) {
        return;
    }
    
    // 创建版本导航元素
    const navElement = createVersionNavElement(messageElement, versionData);
    
    // 将导航添加到消息操作按钮组中
    const messageActions = messageElement.querySelector('.message-actions');
    if (messageActions) {
        messageActions.appendChild(navElement);
    } else {
        // 如果找不到消息操作按钮组，创建一个
        const messageWrapper = messageElement.querySelector('.message-wrapper');
        if (messageWrapper) {
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            actionsDiv.appendChild(navElement);
            messageWrapper.appendChild(actionsDiv);
        }
    }
}

// 强制创建版本导航
function createVersionNav(messageElement, versionData) {
    // 创建版本导航元素
    const navElement = createVersionNavElement(messageElement, versionData);
    
    // 获取或创建消息操作按钮组
    let messageActions = messageElement.querySelector('.message-actions');
    if (!messageActions) {
        const messageWrapper = messageElement.querySelector('.message-wrapper');
        if (messageWrapper) {
            messageActions = document.createElement('div');
            messageActions.className = 'message-actions';
            messageActions.style.opacity = '1'; // 确保可见
            messageWrapper.appendChild(messageActions);
        } else {
            return;
        }
    }
    
    // 设置消息操作按钮组的样式，确保可见
    messageActions.style.opacity = '1';
    
    // 添加版本导航
    messageActions.appendChild(navElement);
    
}

// 创建版本导航元素
function createVersionNavElement(messageElement, versionData) {
    const navElement = document.createElement('div');
    navElement.className = 'response-versions-nav';
    
    // 上一个版本按钮
    const prevBtn = document.createElement('button');
    prevBtn.className = 'version-nav-btn';
    prevBtn.innerHTML = '&lt;';
    prevBtn.title = '查看上一个版本的回答';
    prevBtn.disabled = versionData.currentVersion === 0;
    prevBtn.onclick = () => navigateResponseVersion(messageElement, -1);
    
    // 当前版本/总版本
    const versionInfo = document.createElement('span');
    versionInfo.className = 'version-info';
    versionInfo.textContent = `${versionData.currentVersion + 1}/${versionData.versions.length}`;
    
    // 下一个版本按钮
    const nextBtn = document.createElement('button');
    nextBtn.className = 'version-nav-btn';
    nextBtn.innerHTML = '&gt;';
    nextBtn.title = '查看下一个版本的回答';
    nextBtn.disabled = versionData.currentVersion === versionData.versions.length - 1;
    nextBtn.onclick = () => navigateResponseVersion(messageElement, 1);
    
    // 组合导航元素
    navElement.appendChild(prevBtn);
    navElement.appendChild(versionInfo);
    navElement.appendChild(nextBtn);
    
    return navElement;
}

// 导航到不同的回答版本
function navigateResponseVersion(messageElement, direction) {
    const userMessageId = getUserMessageId(messageElement);
    if (!userMessageId || !responseVersionsMap.has(userMessageId)) {
        return;
    }
    
    const versionData = responseVersionsMap.get(userMessageId);
    const newVersionIndex = versionData.currentVersion + direction;
    
    // 确保索引在有效范围内
    if (newVersionIndex < 0 || newVersionIndex >= versionData.versions.length) {
        return;
    }
    
    // 更新当前版本
    versionData.currentVersion = newVersionIndex;
    
    // 更新UI内容
    const contentElement = messageElement.querySelector('.message-content');
    if (contentElement) {
        // 添加淡出效果
        contentElement.style.opacity = '0';
        contentElement.style.transform = 'translateY(-5px)';
        contentElement.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
        
        // 短暂延迟后更新内容并淡入
        setTimeout(() => {
            contentElement.innerHTML = formatMessage(versionData.versions[newVersionIndex]);
            // 处理代码块和其他格式
            processCodeBlocks(contentElement, versionData.versions[newVersionIndex]);
            
            // 淡入效果
            contentElement.style.opacity = '1';
            contentElement.style.transform = 'translateY(0)';
            
            // 添加过渡动画类
            contentElement.classList.add('version-transition');
            
            // 动画结束后移除类
            setTimeout(() => {
                contentElement.classList.remove('version-transition');
            }, 300);
        }, 200);
    }
    
    // 更新导航UI
    updateVersionNavigation(messageElement, versionData);
}

// 修改addMessage函数，添加版本跟踪
function addMessage(content, sender = 'user', onComplete = () => {}, relatedUserMessageId = null, isHtml = false) {
    const messagesContainer = document.querySelector('.chat-messages');
    const template = document.getElementById('messageTemplate');
    const messageElement = template.content.cloneNode(true);
    const messageDiv = messageElement.querySelector('.message');
    
    messageDiv.classList.add(sender);
    
    // 为用户消息添加唯一ID
    if (sender === 'user') {
        messageDiv.dataset.messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        // 显示编辑按钮（仅用户消息）
        const editBtn = messageDiv.querySelector('.edit-user-message-btn');
        if (editBtn) {
            editBtn.style.display = 'flex';
        }
    } else {
        // 隐藏编辑按钮（AI消息）
        const editBtn = messageDiv.querySelector('.edit-user-message-btn');
        if (editBtn) {
            editBtn.style.display = 'none';
        }
    }
    
    const messageContent = messageDiv.querySelector('.message-content');
    messageContent.innerHTML = ''; // 清空初始内容

    if (sender === 'ai') {
        // 设置全局状态为正在生成
        window.isGeneratingResponse = true;
        window.stopResponseGeneration = false;
        
        // 使用指定的用户消息ID或找到前一个用户消息
        let userMessageId = relatedUserMessageId;
        let userMessageElement = null;
        
        if (!userMessageId) {
            // 没有指定ID，找到最后一个用户消息
            const lastUserMessage = Array.from(messagesContainer.querySelectorAll('.message.user')).pop();
            if (lastUserMessage) {
                userMessageId = lastUserMessage.dataset.messageId;
                userMessageElement = lastUserMessage;
            }
        } else {
            // 使用指定的ID查找用户消息元素
            userMessageElement = document.querySelector(`.message.user[data-message-id="${userMessageId}"]`);
        }
        
        if (userMessageId) {
            // 将此AI回答与用户问题关联
            const versionData = addMessageVersion(userMessageId, content);
            
            // 设置关联，用于后续版本管理
            messageDiv.dataset.responseFor = userMessageId;
            
            // 在消息渲染完成后添加版本导航
            setTimeout(() => {
                updateVersionNavigation(messageDiv, versionData);
            }, 100);
        }
        
        // 初始化空内容
        messageContent.innerHTML = '';
        
        // 添加走马灯效果
        messageContent.style.background = 'linear-gradient(90deg, rgba(16, 163, 127, 0.1) 25%, rgba(16, 163, 127, 0.2) 50%, rgba(16, 163, 127, 0.1) 75%)';
        messageContent.style.backgroundSize = '200% 100%';
        messageContent.style.animation = 'marquee 2s linear infinite';

        // 准备开始打字前，重置滚动状态
        prepareForTypingEffect();
        
        // 如果是HTML内容，直接设置
        if (isHtml) {
            messageContent.innerHTML = content;
            processCodeBlocks(messageContent, content);
            // 更新全局状态
            window.isGeneratingResponse = false;
            updateSendButtonToNormal();
            onComplete();
        } else {
        // 使用打字机效果（使用设置）
        typeWriterWithSettings(messageContent, content, () => {
            // 更新全局状态
            window.isGeneratingResponse = false;
            updateSendButtonToNormal();
            onComplete();
        }, messagesContainer);
        }
    } 
    else {
        // 用户消息处理
        if (isHtml) {
            // 如果是HTML内容，直接设置
            messageContent.innerHTML = content;
        processCodeBlocks(messageContent, content);
        } else {
            // 普通文本处理
            processCodeBlocks(messageContent, content);
        }
        onComplete(); 
    }

    // 设置头像
    const avatarImg = messageDiv.querySelector('.avatar img');
    if (sender === 'user') {
        avatarImg.src = "/static/1.jpg";
    } else {
        avatarImg.src = '/static/2.png';
    }

    messagesContainer.appendChild(messageElement);
    scrollToBottomIfNeeded(messagesContainer);
}

function addFormattedMessage(rawText, sender, htmlContent) {
    const messagesContainer = document.querySelector('.chat-messages');
    const template = document.getElementById('messageTemplate');
    const messageElement = template.content.cloneNode(true);
    const messageDiv = messageElement.querySelector('.message');
    
    // 设置消息类型样式
    messageDiv.classList.add(sender);
    
    // 为用户消息添加唯一ID和显示编辑按钮
    if (sender === 'user') {
        messageDiv.dataset.messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        // 显示编辑按钮（仅用户消息）
        const editBtn = messageDiv.querySelector('.edit-user-message-btn');
        if (editBtn) {
            editBtn.style.display = 'flex';
        }
    } else {
        // 隐藏编辑按钮（AI消息）
        const editBtn = messageDiv.querySelector('.edit-user-message-btn');
        if (editBtn) {
            editBtn.style.display = 'none';
        }
    }
    
    // 注入原始HTML内容
    const messageContent = messageDiv.querySelector('.message-content');
    messageContent.innerHTML = htmlContent;

    // 重新处理代码块（关键步骤）
    processCodeBlocks(messageContent, rawText);

    // 设置头像
    const avatarImg = messageDiv.querySelector('.avatar img');
    avatarImg.src = sender === 'user' ? "/static/1.jpg" : '/static/2.png';

    // 重新绑定复制按钮事件
    messageContent.querySelectorAll('.copy-button').forEach(btn => {
        btn.onclick = () => copyCode(btn);
    });

    messagesContainer.appendChild(messageDiv);
    scrollToBottomIfNeeded(messagesContainer);
}

function processCodeBlocks(container, content) {
    // 添加容错处理，防止不完整的代码块破坏格式
    let processedContent = content;
    
    // 处理未闭合的代码块
    const codeBlockMatches = processedContent.match(/```/g);
    const codeBlocks = codeBlockMatches ? codeBlockMatches.length : 0;
    
    if (codeBlocks % 2 !== 0) { // 奇数个说明有未闭合
        processedContent += '\n```'; // 临时补充闭合
    }

    // 处理文件附件标记 [已上传文件：file1.pdf, file2.docx]
    processedContent = processedContent.replace(/\[已上传文件：(.+?)\]/g, (match, fileNames) => {
        
        // 将文件附件信息保存到消息元素的data属性中，稍后处理
        if (container.parentNode) {
            container.parentNode.dataset.attachedFiles = fileNames;
            
            // 在消息下方添加文件列表
            setTimeout(() => {
                const messageDiv = container.closest('.message');
                if (messageDiv) {
                    
                    // 检查是否已经有了文件列表，防止重复添加
                    const existingFilesList = messageDiv.nextElementSibling;
                    if (existingFilesList && existingFilesList.classList.contains('message-files')) {
                        return;
                    }
                    
                    const files = fileNames.split(',').map(name => name.trim());
                    
                    // 创建文件元素
                    const filesElement = document.createElement('div');
                    filesElement.className = 'message-files';
                    filesElement.style.marginTop = '0';
                    
                    // 判断是否为用户消息，修正位置逻辑
                    const isUserMessage = messageDiv.classList.contains('user');
                    filesElement.style.marginLeft = isUserMessage ? 'auto' : '40px';
                    filesElement.style.marginRight = isUserMessage ? '40px' : 'auto';
                    
                    // 设置对齐方式，用户消息右对齐，AI消息左对齐
                    filesElement.style.display = 'flex';
                    filesElement.style.flexWrap = 'wrap';
                    filesElement.style.gap = '6px';
                    filesElement.style.justifyContent = isUserMessage ? 'flex-end' : 'flex-start';
                    
                    // 添加文件
                    files.forEach(fileName => {
                        const fileExt = fileName.split('.').pop().toLowerCase();
                        
                        // 创建文件元素
                        const fileItem = document.createElement('div');
                        fileItem.className = 'message-file';
                        fileItem.style.display = 'flex';
                        fileItem.style.alignItems = 'center';
                        fileItem.style.cursor = 'pointer';
                        fileItem.style.padding = '3px 6px';
                        fileItem.style.borderRadius = '4px';
                        fileItem.onclick = () => {
                            previewFile(fileName, fileExt);
                        };
                        fileItem.dataset.filename = fileName; // 添加数据属性，用于标识文件名
                        
                        // 添加图标
                        const iconWrapper = document.createElement('div');
                        iconWrapper.className = `file-icon-wrapper ${fileExt}`;
                        iconWrapper.style.background = 'transparent';
                        iconWrapper.style.marginRight = '4px';
                        
                        // 根据文件类型设置图标
                        let iconSvg = getFileIconSvg(fileExt);
                        iconWrapper.innerHTML = iconSvg;
                        
                        // 添加文件名
                        const fileNameElement = document.createElement('span');
                        fileNameElement.className = 'file-name'; // 添加类名，便于后续查找
                        fileNameElement.textContent = fileName;
                        fileNameElement.style.fontSize = '11px';
                        fileNameElement.style.maxWidth = '120px';
                        fileNameElement.style.overflow = 'hidden';
                        fileNameElement.style.textOverflow = 'ellipsis';
                        fileNameElement.style.whiteSpace = 'nowrap';
                        
                        // 组合元素
                        fileItem.appendChild(iconWrapper);
                        fileItem.appendChild(fileNameElement);
                        filesElement.appendChild(fileItem);
                        
                        // 为每个文件添加颜色标识，以增强视觉效果
                        if (isUserMessage) {
                            fileItem.style.backgroundColor = 'rgba(45, 155, 240, 0.1)';
                            fileItem.style.border = '1px solid rgba(45, 155, 240, 0.2)';
                        } else {
                            fileItem.style.backgroundColor = 'rgba(16, 163, 127, 0.1)';
                            fileItem.style.border = '1px solid rgba(16, 163, 127, 0.2)';
                        }
                    });
                    
                    // 将文件元素添加到消息后（在消息外部）
                    messageDiv.parentNode.insertBefore(filesElement, messageDiv.nextSibling);
                }
            }, 0);
        }
        
        // 从消息中移除文件附件标记
        return '';
    });

    // 原有处理逻辑改进，更加稳健地处理代码块
    if (processedContent.includes('```')) {
        // 使用正则表达式匹配代码块，包括不完整的代码块
        const parts = processedContent.split(/(```[\s\S]*?(?:```|$))/g);
        
        // 清空当前内容并准备重建
        let newHTML = '';
        
        // 处理每个部分
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            
            if (part.startsWith('```')) {
                // 这是一个代码块
                const isComplete = part.endsWith('```') && part.length > 6;
                
                if (isComplete) {
                    // 完整的代码块
                const firstLineEnd = part.indexOf('\n');
                    // 如果没有找到换行符，就使用默认语言
                    const firstLine = firstLineEnd > 0 ? part.slice(3, firstLineEnd).trim() : 'text';
                    const code = firstLineEnd > 0 ? part.slice(firstLineEnd + 1, -3) : part.slice(3, -3);
                
                    newHTML += `<div class="code-block-wrapper">
                            <div class="code-block">
                            <pre><code class="language-${firstLine}">${
                                code.replace(/&/g, '&amp;')
                                    .replace(/</g, '&lt;')
                                    .replace(/>/g, '&gt;')
                                    .replace(/"/g, '&quot;')
                                    .replace(/'/g, '&#039;')
                            }</code></pre>
                                <button class="copy-button" onclick="copyCode(this)">复制代码</button>
                            </div>
                        </div>`;
            } else {
                    // 不完整的代码块，添加临时闭合
                    const firstLineEnd = part.indexOf('\n');
                    const firstLine = firstLineEnd > 0 ? part.slice(3, firstLineEnd).trim() : 'text';
                    const code = firstLineEnd > 0 ? part.slice(firstLineEnd + 1) : part.slice(3);
                    
                    newHTML += `<div class="code-block-wrapper">
                        <div class="code-block">
                            <pre><code class="language-${firstLine}">${
                                code.replace(/&/g, '&amp;')
                                    .replace(/</g, '&lt;')
                                    .replace(/>/g, '&gt;')
                                    .replace(/"/g, '&quot;')
                                    .replace(/'/g, '&#039;')
                            }</code></pre>
                            <button class="copy-button" onclick="copyCode(this)">复制代码</button>
                        </div>
                    </div>`;
                }
            } else if (part.trim() !== '') {
                // 普通文本，处理换行符
                newHTML += part.replace(/\n/g, '<br>');
            }
        }
        
        // 更新容器内容
        container.innerHTML = newHTML;
    } else {
        // 没有代码块，直接处理文本和换行符
        container.innerHTML = processedContent.replace(/\n/g, '<br>');
    }
    
    // 重新绑定复制按钮
    container.querySelectorAll('.copy-button').forEach(btn => {
        btn.onclick = () => copyCode(btn);
    });
}

function addLoadingMessage() {
    const messagesContainer = document.querySelector('.chat-messages');
    const messageElement = document.createElement('div');
    messageElement.className = 'message ai loading';
    
    const avatar = document.createElement('div');
    avatar.className = 'avatar';
    const avatarImg = document.createElement('img');
    avatarImg.src = '/static/2.png';
    avatar.appendChild(avatarImg);
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    contentDiv.innerHTML = `
        <div class="loading-dots">
            <span></span>
            <span></span>
            <span></span>
        </div>
    `;
    
    messageElement.appendChild(avatar);
    messageElement.appendChild(contentDiv);
    
    messagesContainer.appendChild(messageElement);
    scrollToBottomIfNeeded(messagesContainer);
    
    return messageElement;
}

function startNewChat() {
    // 清除任何活跃对话的状态
    const activeChats = document.querySelectorAll('.history-item.active');
    activeChats.forEach(item => item.classList.remove('active'));
    
    // 清空当前对话
    const chatMessages = document.getElementById('chatMessages');
    chatMessages.innerHTML = '';
    
    // 清除标题
    document.getElementById('chatTitle').style.display = 'none';
    document.getElementById('chatTitleText').textContent = '';
    window.currentChatTitle = null;
    
    // 添加欢迎语（使用与页面加载时相同的方式）
    addMessage('您好！我是AI助手。我可以帮您分析Excel数据，也可以回答您的其他问题。如果需要数据分析，请上传Excel文件后告诉我您想了解什么。', 'ai');
    
    // 清空输入和文件
    document.getElementById('userInput').value = '';
    const fileList = document.getElementById('fileList');
    fileList.innerHTML = '';
    fileList.style.display = 'none';

    // 清空文件输入框
    const fileInput = document.getElementById('fileInput');
    if (fileInput) fileInput.value = '';
    
    // 清空全局文件数组
    uploadedFiles.length = 0;
}

function addToHistory(title) {
    const chatHistory = document.getElementById('historyList');
    const now = new Date();
    
    const chatItem = document.createElement('div');
    chatItem.className = 'history-item';
    chatItem.innerHTML = `
        <span class="text">${title}</span>
    `;
    
    if (chatHistory.firstChild) {
        chatHistory.insertBefore(chatItem, chatHistory.firstChild);
    } else {
        chatHistory.appendChild(chatItem);
    }
}

// 复制消息内容
async function copyMessage(button) {
    const messageContent = button.closest('.message-wrapper').querySelector('.message-content').textContent;
    try {
        await navigator.clipboard.writeText(messageContent);
        
        // 显示复制成功提示
        const originalText = button.innerHTML;
        button.innerHTML = `
            <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="16" width="16">
                <path d="M20 6L9 17l-5-5"></path>
            </svg>
            已复制
        `;
        
        setTimeout(() => {
            button.innerHTML = originalText;
        }, 2000);
    } catch (err) {
        console.error('复制失败:', err);
        alert('复制失败，请手动复制');
    }
}

// 文件名标准化处理函数
function normalizeFileName(fileName) {
    if (!fileName) return '';
    
    // 去除首尾空格
    let normalized = fileName.trim();
    
    // 替换连续的空格为单个空格
    normalized = normalized.replace(/\s+/g, ' ');
    
    // 处理潜在的"未命名.txt"变成"txt"的情况
    if (normalized === 'txt' && fileName.includes('未命名')) {
        normalized = '未命名.txt';
    }
    
    return normalized;
}

// 计算两个字符串之间的编辑距离（Levenshtein距离）
function levenshteinDistance(str1, str2) {
    // 创建矩阵
    const matrix = Array(str1.length + 1).fill().map(() => Array(str2.length + 1).fill(0));
    
    // 初始化第一行和第一列
    for (let i = 0; i <= str1.length; i++) {
        matrix[i][0] = i;
    }
    for (let j = 0; j <= str2.length; j++) {
        matrix[0][j] = j;
    }
    
    // 填充矩阵
    for (let i = 1; i <= str1.length; i++) {
        for (let j = 1; j <= str2.length; j++) {
            const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(
                matrix[i - 1][j] + 1,      // 删除
                matrix[i][j - 1] + 1,      // 插入
                matrix[i - 1][j - 1] + cost // 替换
            );
        }
    }
    
    // 返回右下角的值，即编辑距离
    return matrix[str1.length][str2.length];
}

// 重新生成回答
async function regenerateResponse(button) {
    console.log("===== 开始重新生成回答 =====");
    console.log("按钮元素:", button);
    
    // 获取消息元素
    const messageElement = button.closest('.message');
    console.log("AI消息元素:", messageElement);
    
    // 检查DOM结构
    console.log("消息元素的父元素:", messageElement.parentElement);
    console.log("消息元素的前一个兄弟元素:", messageElement.previousElementSibling);
    console.log("消息元素的所有兄弟元素:", Array.from(messageElement.parentElement.children).map(el => el.className));
    
    // 尝试获取用户消息元素
    let userMessageElement = messageElement.previousElementSibling;
    console.log("用户消息元素:", userMessageElement);
    
    if (!userMessageElement) {
        console.error("无法找到用户消息元素");
        alert('无法找到对应的问题内容');
        return;
    }
    
    // 检查用户消息元素的类名
    console.log("用户消息元素类名:", userMessageElement.className);
    
    // 检查是否为用户消息
    if (!userMessageElement.classList.contains('user')) {
        console.warn("前一个元素不是用户消息，尝试查找最近的用户消息");
        
        // 尝试查找最近的用户消息
        let currentElement = messageElement;
        let foundUserMessage = null;
        
        // 向前查找最多5个元素
        for (let i = 0; i < 5; i++) {
            currentElement = currentElement.previousElementSibling;
            if (!currentElement) break;
            
            console.log("检查元素:", currentElement.className);
            if (currentElement.classList.contains('user')) {
                foundUserMessage = currentElement;
                break;
            }
        }
        
        if (foundUserMessage) {
            console.log("找到用户消息元素:", foundUserMessage);
            userMessageElement = foundUserMessage;
        } else {
            console.error("无法找到对应的用户消息");
            alert('无法找到对应的问题内容');
            return;
        }
    }
    
    // 获取用户消息内容
    const contentElement = userMessageElement.querySelector('.message-content');
    console.log("用户消息内容元素:", contentElement);
    
    if (!contentElement) {
        console.error("无法找到消息内容元素");
        alert('无法找到对应的问题内容');
        return;
    }
    
    const userMessage = contentElement.textContent;
    console.log("用户消息内容:", userMessage);
    
    // 检查用户消息元素的data-attached-files属性
    console.log("用户消息元素的附件属性:", userMessageElement.dataset.attachedFiles);
    
    // 检查消息下方是否有文件元素
    const nextElement = userMessageElement.nextElementSibling;
    console.log("用户消息的下一个元素:", nextElement);
    if (nextElement && nextElement.classList.contains('message-files')) {
        console.log("找到消息文件元素:", nextElement);
    }
    
    const userMessageId = getUserMessageId(messageElement);
    console.log("用户消息ID:", userMessageId);
    
    if (!userMessage) {
        console.error("用户消息内容为空");
        alert('无法找到对应的问题内容');
        return;
    }
    
    // 提取文件信息 - 从多个来源尝试获取
    let hasFiles = false;
    let filesInfo = [];
    
    // 方法1: 从消息文本中提取
    if (userMessage.includes('[已上传文件：')) {
        hasFiles = true;
        const fileMatch = userMessage.match(/\[已上传文件：(.+?)\]/);
        if (fileMatch && fileMatch[1]) {
            filesInfo = fileMatch[1].split(',').map(name => normalizeFileName(name.trim()));
            console.log("方法1-从消息文本中提取到文件:", filesInfo);
        }
    }
    
    // 方法2: 从data-attached-files属性中提取
    if (userMessageElement.dataset.attachedFiles) {
        hasFiles = true;
        const attachedFiles = userMessageElement.dataset.attachedFiles.split(',').map(name => normalizeFileName(name.trim()));
        console.log("方法2-从data属性中提取到文件:", attachedFiles);
        
        // 合并文件列表，避免重复
        attachedFiles.forEach(file => {
            if (!filesInfo.includes(file)) {
                filesInfo.push(file);
            }
        });
    }
    
    // 方法3: 检查下一个元素是否为文件列表
    if (nextElement && nextElement.classList.contains('message-files')) {
        hasFiles = true;
        const fileElements = nextElement.querySelectorAll('.file-attachment');
        const fileNamesFromDOM = Array.from(fileElements).map(el => {
            const nameEl = el.querySelector('.file-name');
            return nameEl ? normalizeFileName(nameEl.textContent.trim()) : '';
        }).filter(name => name);
        
        console.log("方法3-从DOM中提取到文件:", fileNamesFromDOM);
        
        // 合并文件列表，避免重复
        fileNamesFromDOM.forEach(file => {
            if (!filesInfo.includes(file)) {
                filesInfo.push(file);
            }
        });
    }
    
    console.log("最终合并的文件列表:", filesInfo);
    
    // 保存当前消息元素的引用
    const originalMessageElement = messageElement;
    
    // 显示加载状态 - 在当前消息上显示
    const messageContent = originalMessageElement.querySelector('.message-content');
    if (messageContent) {
        // 保存原始内容以备恢复
        const originalContent = messageContent.innerHTML;
        
        // 显示加载动画
        messageContent.innerHTML = `
            <div style="text-align:center;width:100%;padding:20px;">
                <div class="loading-dots">
                    <span style="animation-delay: 0s;"></span>
                    <span style="animation-delay: 0.2s;"></span>
                    <span style="animation-delay: 0.4s;"></span>
                </div>
                <p>正在重新生成回答...</p>
            </div>
        `;
    }
    
    try {
        const formData = new FormData();
        
        // 提取不包含文件信息的纯问题内容
        let cleanMessage = userMessage;
        if (hasFiles) {
            cleanMessage = userMessage.replace(/\[已上传文件：(.+?)\]/g, '').trim();
            console.log("清理后的消息内容:", cleanMessage);
        }
        
        formData.append('message', cleanMessage);
        
        // 如果有文件，将当前全局文件数组中匹配的文件添加到请求中
        if (hasFiles && uploadedFiles.length > 0) {
            console.log("需要查找的文件:", filesInfo);
            console.log("当前可用的文件:", uploadedFiles.map(f => normalizeFileName(f.name)));
            
            // 更宽松的文件名匹配，忽略空格和大小写差异
            const filesToInclude = uploadedFiles.filter(file => {
                // 检查每个需要的文件名是否能找到匹配
                const normalizedCurrent = normalizeFileName(file.name).toLowerCase();
                
                return filesInfo.some(neededFileName => {
                    const normalizedNeeded = neededFileName.toLowerCase();
                    
                    // 多种匹配方式
                    const exactMatch = normalizedNeeded === normalizedCurrent;
                    const includesMatch = normalizedCurrent.includes(normalizedNeeded) || normalizedNeeded.includes(normalizedCurrent);
                    const similarityMatch = levenshteinDistance(normalizedNeeded, normalizedCurrent) <= 3; // 允许最多3个字符的差异
                    
                    const match = exactMatch || includesMatch || similarityMatch;
                    
                    console.log(`比较: "${normalizedNeeded}" vs "${normalizedCurrent}" => ${match ? '匹配' : '不匹配'} (精确匹配: ${exactMatch}, 包含匹配: ${includesMatch}, 相似度匹配: ${similarityMatch})`);
                    return match;
                });
            });
            
            if (filesToInclude.length > 0) {
                console.log(`找到 ${filesToInclude.length} 个匹配的文件，添加到重新回答请求中:`);
                filesToInclude.forEach(file => {
                    console.log(`- ${file.name} (${file.size} bytes)`);
                    formData.append('files[]', file);
                });
            } else {
                console.warn("警告：找不到原始上传的文件，可能影响重新回答结果。");
                console.warn("需要的文件:", filesInfo);
                console.warn("可用的文件:", uploadedFiles.map(f => f.name));
                
                // 尝试修复"未命名.txt"变成"txt"的情况
                const fixedFilesToInclude = uploadedFiles.filter(file => {
                    const fileName = file.name.toLowerCase();
                    return fileName === 'txt' || fileName.includes('未命名');
                });
                
                if (fixedFilesToInclude.length > 0 && filesInfo.some(f => f.includes('未命名') || f === 'txt')) {
                    console.log("找到可能的未命名.txt文件，尝试使用它:");
                    fixedFilesToInclude.forEach(file => {
                        console.log(`- ${file.name} (${file.size} bytes)`);
                        formData.append('files[]', file);
                    });
                } else {
                    // 如果实在找不到匹配的文件，尝试添加所有文件，但不显示确认对话框
                    if (uploadedFiles.length > 0) {
                        console.log("未找到精确匹配的文件，自动使用所有当前文件:");
                        uploadedFiles.forEach(file => {
                            console.log(`- ${file.name} (${file.size} bytes)`);
                            formData.append('files[]', file);
                        });
                    } else {
                        // 恢复原始内容，并显示错误消息
                        if (messageContent) {
                            messageContent.innerHTML = originalContent;
                            
                            // 显示更友好的错误提示
                            alert('无法找到任何上传的文件，请重新上传文件后再尝试。\n\n这通常是因为页面刷新或浏览器重启导致的，上传的文件只在当前会话中有效。');
                            return;
                        }
                    }
                }
            }
        }
        
        const response = await fetch('/api/ai_analysis', {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            throw new Error(`服务器响应错误 (${response.status})`);
        }
        
        const data = await response.json();
        
        if (data.success) {
            const newContent = data.response;
            const messageContent = originalMessageElement.querySelector('.message-content');
            messageContent.innerHTML = '';
            
            // 添加走马灯效果
            messageContent.style.background = 'linear-gradient(90deg, rgba(16, 163, 127, 0.1) 25%, rgba(16, 163, 127, 0.2) 50%, rgba(16, 163, 127, 0.1) 75%)';
            messageContent.style.backgroundSize = '200% 100%';
            messageContent.style.animation = 'marquee 2s linear infinite';
            
            // 准备开始打字前，重置滚动状态
            prepareForTypingEffect();
            
            // 使用打字机效果（使用设置）
            const messagesContainer = document.querySelector('.chat-messages');
            typeWriterWithSettings(messageContent, newContent, () => {
                // 原来typeWriter结束后的回调代码
                if (!userMessageId) {
                    // 重新尝试获取用户消息ID
                    const updatedUserMessageId = getUserMessageId(originalMessageElement);
                    if (updatedUserMessageId) {
                        console.log("打字机效果结束时找到用户消息ID:", updatedUserMessageId);
                        const versionData = addMessageVersion(updatedUserMessageId, newContent);
                        // 强制显示版本导航，即使只有一个版本
                        versionData.forceShow = true;
                        setTimeout(() => {
                            updateVersionNavigation(originalMessageElement, versionData);
                            
                            // 检查是否成功添加了版本导航
                            const navAdded = originalMessageElement.querySelector('.response-versions-nav');
                            console.log("版本导航添加状态:", navAdded ? "成功" : "失败");
                            if (!navAdded) {
                                console.warn("尝试强制创建版本导航");
                                // 强制创建版本导航
                                createVersionNav(originalMessageElement, versionData);
                            }
                        }, 100);
                    }
                } else {
                    const versionData = addMessageVersion(userMessageId, newContent);
                    // 强制显示版本导航，即使只有一个版本
                    versionData.forceShow = true;
                    setTimeout(() => {
                        updateVersionNavigation(originalMessageElement, versionData);
                        
                        // 检查是否成功添加了版本导航
                        const navAdded = originalMessageElement.querySelector('.response-versions-nav');
                        console.log("版本导航添加状态:", navAdded ? "成功" : "失败");
                        if (!navAdded) {
                            console.warn("尝试强制创建版本导航");
                            // 强制创建版本导航
                            createVersionNav(originalMessageElement, versionData);
                        }
                    }, 100);
                }
            }, messagesContainer);
        } else {
            messageContent.innerHTML = `抱歉，处理您的请求时出现错误：${data.message}`;
        }
    } catch (error) {
        console.error('重新生成请求处理错误:', error);
        
        // 恢复原始内容，并显示错误消息
        if (messageContent) {
            messageContent.innerHTML = originalContent;
            
            // 在消息下面添加错误提示
            const errorElement = document.createElement('div');
            errorElement.className = 'error-message';
            errorElement.style.color = 'red';
            errorElement.style.fontSize = '12px';
            errorElement.style.marginTop = '5px';
            errorElement.textContent = '重新生成请求失败，请稍后重试';
            
            messageContent.appendChild(errorElement);
            
            // 3秒后移除错误提示
            setTimeout(() => {
                const errorMsg = messageContent.querySelector('.error-message');
                if (errorMsg) {
                    errorMsg.remove();
                }
            }, 3000);
        }
    }
}

function formatMessage(content) {
    content = content.replace(/<pre><code>([\s\S]*?)<\/code><\/pre>/g, function(match, code) {
        return `
            <div class="code-block-wrapper">
                <div class="code-block">
                    <pre><code>${code}</code></pre>
                    <button class="copy-button" onclick="copyCode(this)">
                        <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                        复制代码
                    </button>
                </div>
            </div>
        `;
    });
    return content;
}

function copyCode(button) {
    const codeBlock = button.parentElement.querySelector('code');
    const text = codeBlock.textContent;
    
    navigator.clipboard.writeText(text).then(() => {
        const originalContent = button.innerHTML;
        button.innerHTML = `
            <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24">
                <path d="M20 6L9 17l-5-5"></path>
            </svg>
            已复制
        `;
        button.classList.add('copied');
        
        setTimeout(() => {
            button.innerHTML = `
                <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                复制代码
            `;
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('复制失败:', err);
        button.innerHTML = `
            <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
            复制失败
        `;
        
        setTimeout(() => {
            button.innerHTML = `
                <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                复制代码
            `;
        }, 2000);
    });
}

// 切换历史记录显示
// 修改toggleHistory函数
async function toggleHistory() {
    const sidebar = document.getElementById('sidebar');
    const historyList = document.getElementById('historyList');
    const settingsPanel = document.getElementById('settingsPanel');
    const isCollapsed = sidebar.classList.contains('collapsed');
    
    // 如果侧边栏已收缩，先展开
    if (isCollapsed) {
        sidebar.classList.remove('collapsed');
        localStorage.setItem('sidebarCollapsed', false);
    }
    
    // 隐藏设置面板
    settingsPanel.style.display = 'none';
    
    const isHidden = historyList.style.display === 'none';
    
    if (isHidden) {
        await updateHistoryList(); // 直接调用updateHistoryList
                historyList.style.display = 'block';
    } else {
        historyList.style.display = 'none';
    }
}

// 更新现有对话
async function updateExistingChat(chatId, messages) {
    try {
        const response = await fetch(`/api/chat_history/${chatId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                message: messages
            })
        });
        
        const data = await response.json();
        if (data.success) {
            // 更新历史记录列表
            await updateHistoryList();
        } else {
            console.error('更新聊天记录失败:', data.message);
        }
    } catch (error) {
        console.error('更新聊天记录失败:', error);
    }
}

// 文件预览功能
function previewFile(fileName, fileExt) {
    const previewPanel = document.getElementById('filePreviewPanel');
    const previewTitle = document.getElementById('previewFileName');
    const previewContent = document.getElementById('previewContent');
    
    console.log('预览文件:', fileName, fileExt); // 保留调试信息
    
    // 设置预览标题
    previewTitle.textContent = fileName;
    
    // 清空预览内容
    previewContent.innerHTML = '';
    
    // 添加加载指示器
    previewContent.innerHTML = `
        <div style="text-align:center;width:100%;padding:20px;">
            <div class="loading-dots">
                <span style="animation-delay: 0s;"></span>
                <span style="animation-delay: 0.2s;"></span>
                <span style="animation-delay: 0.4s;"></span>
            </div>
            <p>正在加载文件...</p>
        </div>
    `;

    // 文件扩展名小写
    const fileExtLower = fileExt.toLowerCase();
    
    // 根据文件类型创建不同的预览
    if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'].includes(fileExtLower)) {
        // 图片预览
        const img = new Image();
        img.style.maxWidth = '100%';
        img.style.height = 'auto';
        img.style.display = 'block';
        img.style.margin = '0 auto';
        
        img.onload = function() {
            previewContent.innerHTML = '';
            previewContent.appendChild(img);
            
            // 添加图片信息
            const imgInfo = document.createElement('div');
            imgInfo.className = 'file-preview-info';
            imgInfo.innerHTML = `尺寸: ${img.naturalWidth} x ${img.naturalHeight} 像素`;
            previewContent.appendChild(imgInfo);
        };
        
        img.onerror = function() {
            previewContent.innerHTML = `
                <div class="file-preview-info" style="color:red;">图片加载失败</div>
                <a href="/api/preview/${encodeURIComponent(fileName)}" target="_blank" class="btn" style="display:inline-block;margin-top:15px;padding:8px 15px;background:var(--primary-color);color:white;border-radius:4px;text-decoration:none;">
                    下载文件
                </a>
            `;
        };
        
        img.src = `/api/preview/${encodeURIComponent(fileName)}`;
        
    } else if (fileExtLower === 'pdf') {
        // PDF文件预览 - 使用iframe
        previewContent.innerHTML = `
            <iframe 
                src="/api/preview/${encodeURIComponent(fileName)}" 
                style="width:100%;height:100%;border:none;" 
                sandbox="allow-scripts"
                onload="this.style.display='block';"
                onerror="document.getElementById('previewContent').innerHTML='<div class=\'file-preview-info\'>PDF加载失败</div>';"
            ></iframe>
        `;
        
    } else if ([
        'txt', 'md', 'py', 'js', 'html', 'css', 'java', 'c', 'cpp', 'h', 
        'php', 'sql', 'json', 'csv', 'xml', 'yaml', 'yml', 'ini', 'cfg', 
        'conf', 'log', 'sh', 'bat', 'ps1', 'rb', 'pl', 'go', 'ts', 'jsx', 
        'tsx', 'vue', 'dart', 'swift', 'kt', 'rs', 'scala', 'lua', 'r'
    ].includes(fileExtLower)) {
        // 文本文件预览 - 从API获取内容
        fetch(`/api/file_content/${encodeURIComponent(fileName)}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`服务器返回状态码: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // 检查是否是二进制文件（不支持文本预览）
                if (data.is_binary) {
                    previewContent.innerHTML = `
                        <div class="file-preview-info">
                            <strong>${fileName}</strong><br>
                            ${data.content}
                        </div>
                        <a href="/api/preview/${encodeURIComponent(fileName)}" target="_blank" class="btn" style="display:inline-block;margin-top:15px;padding:8px 15px;background:var(--primary-color);color:white;border-radius:4px;text-decoration:none;">
                            下载文件
                        </a>
                    `;
                    return;
                }
                
                // 创建文本预览
                const preEl = document.createElement('pre');
                preEl.className = 'file-preview-text';
                preEl.style.whiteSpace = 'pre-wrap';
                preEl.style.overflow = 'auto';
                preEl.style.fontSize = '12px';
                preEl.style.fontFamily = 'monospace';
                preEl.style.lineHeight = '1.4';
                preEl.style.padding = '10px';
                preEl.textContent = data.content;
                
                previewContent.innerHTML = '';
                previewContent.appendChild(preEl);
                
                // 添加文件信息
                const fileInfo = document.createElement('div');
                fileInfo.className = 'file-preview-info';
                fileInfo.innerHTML = `编码: ${data.encoding || 'UTF-8'}`;
                previewContent.appendChild(fileInfo);
            })
            .catch(error => {
                previewContent.innerHTML = `
                    <div class="file-preview-info" style="color:red;">无法加载文件内容：${error.message}</div>
                    <a href="/api/preview/${encodeURIComponent(fileName)}" target="_blank" class="btn" style="display:inline-block;margin-top:15px;padding:8px 15px;background:var(--primary-color);color:white;border-radius:4px;text-decoration:none;">
                        下载文件
                    </a>
                `;
                console.error('文件加载错误:', error);
            });
            
    } else {
        // 其他类型文件 - 提供下载选项
        previewContent.innerHTML = `
            <div class="file-icon-wrapper ${fileExtLower}" style="width:80px;height:80px;margin:20px auto;">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="48" height="48">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"></path>
                </svg>
            </div>
            <div class="file-preview-info" style="text-align:center;">
                <strong>${fileName}</strong><br>
                此类型文件 (.${fileExtLower}) 不支持在线预览，请下载后查看。
            </div>
            <div style="text-align:center;margin-top:15px;">
                <a href="/api/preview/${encodeURIComponent(fileName)}" target="_blank" class="btn" style="display:inline-block;padding:8px 15px;background:var(--primary-color);color:white;border-radius:4px;text-decoration:none;">
                    下载文件
                </a>
            </div>
        `;
    }
    
    // 显示预览面板
    previewPanel.classList.add('show');
}

// 关闭文件预览
function closeFilePreview() {
    const previewPanel = document.getElementById('filePreviewPanel');
    previewPanel.classList.remove('show');
}

// 添加一个辅助函数来获取文件图标SVG
function getFileIconSvg(fileExt) {
    let svg = '';
    
    // 根据文件类型返回不同的SVG图标
    if (['pdf'].includes(fileExt)) {
        svg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M8.267 14.68c-.184 0-.308.018-.372.036v1.178c.076.018.171.023.302.023.479 0 .774-.242.774-.651 0-.366-.254-.586-.704-.586zm3.487.012c-.2 0-.33.018-.407.036v2.61c.077.018.201.018.313.018.817.006 1.349-.444 1.349-1.396.006-.83-.479-1.268-1.255-1.268z"/><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/></svg>';
    } else if (['doc', 'docx'].includes(fileExt)) {
        svg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zM9.293 13.707l.537.24.2.617-.417.228-.228.074a1.874 1.874 0 0 1-2.664-2.258l-.101-.362 1.387-.644.228.618-.982.454a1.01 1.01 0 0 0 1.453 1.249l.453-.24 1.405.649-.538-.24-.201-.617.416-.228.229-.074zM13 9v8l-5-4 5-4z"/></svg>';
    } else if (['xls', 'xlsx', 'csv'].includes(fileExt)) {
        svg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zM15 9h-5V8h5v1zm-7 8.584v-5.443h.93l1.055 2.833 1.059-2.833h.924v5.443h-.924V13.88l-1.059 2.585h-.93L8 13.88v3.704H8z"/></svg>';
    } else if (['txt'].includes(fileExt)) {
        svg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zM9 17H7v-2h2v2zm0-4H7v-2h2v2zm0-4H7V7h2v2zm4 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2zm4 8h-2v-2h2v2zm0-4h-2v-2h2v2z"/></svg>';
    } else if (['json', 'md'].includes(fileExt)) {
        svg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zM9 17H7v-2h2v2zm0-4H7v-2h2v2zm0-4H7V7h2v2zm4 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2zm4 8h-2v-2h2v2zm0-4h-2v-2h2v2z"/></svg>';
    } else if (['jpg', 'jpeg', 'png', 'gif', 'bmp'].includes(fileExt)) {
        svg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/></svg>';
    } else {
        svg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/></svg>';
    }
    
    return svg;
}

function isAllowedFile(file) {
    const maxSize = 100 * 1024 * 1024; // 100MB
    
    if (file.size > maxSize) {
        alert('文件大小不能超过100MB');
        return false;
    }
    
    const fileExtension = file.name.split('.').pop().toLowerCase();
    const allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'pdf', 'doc', 'docx', 'txt', 'csv', 'xls', 'xlsx', 'json', 'md', 'py', 'js', 'html', 'css', 'java', 'c', 'cpp', 'h', 'php', 'sql'];
    
    if (!allowedExtensions.includes(fileExtension)) {
        alert('不支持的文件格式');
        return false;
    }
    
    return true;
}

// 格式化文件大小
function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
    else return (bytes / 1048576).toFixed(1) + ' MB';
}

// 防止默认行为
function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
}

// 高亮拖放区域
function highlight(e) {
    const inputWrapper = document.querySelector('.input-wrapper');
    inputWrapper.style.borderColor = 'var(--primary-color)';
    inputWrapper.style.background = 'rgba(16, 163, 127, 0.05)';
}

// 取消高亮拖放区域
function unhighlight(e) {
    const inputWrapper = document.querySelector('.input-wrapper');
    inputWrapper.style.borderColor = 'var(--border-color)';
    inputWrapper.style.background = 'transparent';
}

// 确保在页面加载完成后初始化文件上传功能
document.addEventListener('DOMContentLoaded', function() {
    initFileUpload();
});

function initFileUpload() {
    const fileInput = document.getElementById('fileInput');
    const uploadButton = document.getElementById('uploadButton');
    
    // 简化文件上传处理
    fileInput.addEventListener('change', function() {
        const files = this.files;
        if (files.length > 0) {
            handleFileSelection(files);
        }
    });
    
    // 点击上传按钮触发文件选择
    if (uploadButton) {
        uploadButton.onclick = function(e) {
            e.preventDefault();
            // 创建新的文件输入元素，避免事件冲突
            const oldInput = document.getElementById('fileInput');
            const newInput = document.createElement('input');
            newInput.type = 'file';
            newInput.id = 'fileInput';
            newInput.multiple = true;
            newInput.style.display = 'none';
            newInput.accept = oldInput.accept;
            
            // 替换旧的输入元素
            oldInput.parentNode.replaceChild(newInput, oldInput);
            
            // 添加change事件监听器
            newInput.addEventListener('change', function() {
                const files = this.files;
                if (files.length > 0) {
                    handleFileSelection(files);
                }
            });
            
            // 触发点击
            newInput.click();
        };
    }
    
    // 设置简单的拖放功能
    // setupSimpleDragAndDrop();
}

// 添加编辑用户消息的功能
function startEditUserMessage(button) {
    const messageElement = button.closest('.message');
    if (!messageElement || !messageElement.classList.contains('user')) {
        return;
    }
    
    // 如果已经在编辑状态，不做任何操作
    if (messageElement.classList.contains('editing')) {
        return;
    }
    
    // 标记消息为编辑状态
    messageElement.classList.add('editing');
    
    // 获取消息内容元素
    const contentElement = messageElement.querySelector('.message-content');
    if (!contentElement) return;
    
    // 保存原始内容，用于取消编辑
    const originalContent = contentElement.innerHTML;
    messageElement.dataset.originalContent = originalContent;
    
    // 提取纯文本内容（去除文件附件标记）
    let textContent = contentElement.textContent;
    const fileMatch = textContent.match(/\[已上传文件：(.+?)\]/);
    let fileAttachmentText = '';
    
    if (fileMatch) {
        fileAttachmentText = fileMatch[0];
        textContent = textContent.replace(fileAttachmentText, '').trim();
    }
    
    // 使内容可编辑
    contentElement.setAttribute('contenteditable', 'true');
    contentElement.focus();
    
    // 创建编辑操作按钮
    const editActions = document.createElement('div');
    editActions.className = 'edit-actions';
    editActions.innerHTML = `
        <button class="cancel-edit-btn" onclick="cancelEditUserMessage(this)">
            <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="14" width="14" style="margin-right: 4px; vertical-align: -2px;">
                <path d="M6 18L18 6M6 6l12 12"></path>
            </svg>
            取消
        </button>
        <button class="save-edit-btn" onclick="saveEditUserMessage(this)">
            <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" height="14" width="14" style="margin-right: 4px; vertical-align: -2px;">
                <path d="M5 13l4 4L19 7"></path>
            </svg>
            保存并重新发送
        </button>
    `;
    
    // 添加编辑操作按钮到消息元素
    messageElement.querySelector('.message-wrapper').appendChild(editActions);
    
    // 保存文件附件信息
    if (fileAttachmentText) {
        messageElement.dataset.fileAttachment = fileAttachmentText;
    }
    
    // 隐藏编辑按钮
    button.style.display = 'none';
    
    // 将光标定位到文本末尾
    const range = document.createRange();
    const selection = window.getSelection();
    range.selectNodeContents(contentElement);
    range.collapse(false); // 将光标定位到末尾
    selection.removeAllRanges();
    selection.addRange(range);
}

// 取消编辑用户消息
function cancelEditUserMessage(button) {
    const messageElement = button.closest('.message');
    if (!messageElement) return;
    
    // 恢复原始内容
    const contentElement = messageElement.querySelector('.message-content');
    if (contentElement && messageElement.dataset.originalContent) {
        contentElement.innerHTML = messageElement.dataset.originalContent;
        contentElement.removeAttribute('contenteditable');
    }
    
    // 移除编辑状态和操作按钮
    messageElement.classList.remove('editing');
    const editActions = messageElement.querySelector('.edit-actions');
    if (editActions) {
        editActions.remove();
    }
    
    // 重新显示编辑按钮
    const editButton = messageElement.querySelector('.edit-user-message-btn');
    if (editButton) {
        editButton.style.display = '';
    }
    
    // 清除临时数据
    delete messageElement.dataset.originalContent;
    // 保留文件附件信息，以便将来再次编辑
    // delete messageElement.dataset.fileAttachment;
}

// 保存编辑并重新发送消息
async function saveEditUserMessage(button) {
    const messageElement = button.closest('.message');
    if (!messageElement) return;
    
    // 获取编辑后的内容
    const contentElement = messageElement.querySelector('.message-content');
    if (!contentElement) return;
    
    // 获取编辑后的文本内容
    let newContent = contentElement.textContent.trim();
    
    // 检查是否有文件附件信息（检查数据属性和相邻的文件列表元素）
    let fileNames = [];
    let hasFileAttachment = false;

    // 1. 检查数据属性
    if (messageElement.dataset.fileAttachment || messageElement.dataset.attachedFiles) {
        hasFileAttachment = true;
        
        if (messageElement.dataset.fileAttachment) {
            const fileMatch = messageElement.dataset.fileAttachment.match(/\[已上传文件：(.+?)\]/);
            if (fileMatch && fileMatch[1]) {
                fileNames = fileMatch[1].split(',').map(name => name.trim());
            }
        }
        
        if (messageElement.dataset.attachedFiles && fileNames.length === 0) {
            fileNames = messageElement.dataset.attachedFiles.split(',').map(name => name.trim());
        }
    }
    
    // 2. 检查相邻的文件列表元素
    if (fileNames.length === 0) {
        const nextElement = messageElement.nextElementSibling;
        if (nextElement && nextElement.classList.contains('message-files')) {
            hasFileAttachment = true;
            
            // 从文件列表元素中提取文件名
            const fileElements = nextElement.querySelectorAll('.file-name');
            fileElements.forEach(el => {
                if (el.textContent) {
                    fileNames.push(el.textContent.trim());
                }
            });
            
            // 如果仍然没有找到，尝试从dataset.filename属性获取
            if (fileNames.length === 0) {
                const fileItems = nextElement.querySelectorAll('.message-file');
                fileItems.forEach(item => {
                    if (item.dataset.filename) {
                        fileNames.push(item.dataset.filename.trim());
                    }
                });
            }
        }
    }
    
    // 如果有文件附件，添加文件附件标记到内容中
    if (hasFileAttachment && fileNames.length > 0) {
        const fileAttachmentText = `[已上传文件：${fileNames.join(', ')}]`;
        newContent += ' ' + fileAttachmentText;
    }
    
    // 保存原始HTML内容用于版本管理
    const originalContent = contentElement.innerHTML;
    
    // 移除编辑状态和操作按钮
    messageElement.classList.remove('editing');
    contentElement.removeAttribute('contenteditable');
    const editActions = messageElement.querySelector('.edit-actions');
    if (editActions) {
        editActions.remove();
    }
    
    // 重新显示编辑按钮
    const editButton = messageElement.querySelector('.edit-user-message-btn');
    if (editButton) {
        editButton.style.display = '';
    }
    
    // 更新消息内容
    processCodeBlocks(contentElement, newContent);
    
    // 保存用户消息版本
    const userMessageId = messageElement.dataset.messageId;
    if (userMessageId) {
        // 保存用户消息版本
        let userVersionData;
        if (!userMessageVersionsMap.has(userMessageId)) {
            userVersionData = {
                versions: [originalContent],
                currentVersion: 0,
                forceShow: true // 强制显示版本导航
            };
            userMessageVersionsMap.set(userMessageId, userVersionData);
        } else {
            userVersionData = userMessageVersionsMap.get(userMessageId);
            userVersionData.versions.push(contentElement.innerHTML);
            userVersionData.currentVersion = userVersionData.versions.length - 1;
            userVersionData.forceShow = true;
        }
        
        // 添加用户消息版本导航
        updateUserMessageVersionNavigation(messageElement, userVersionData);
    }
    
    // 立即查找并删除所有与此用户消息关联的AI回答元素
    const messagesContainer = document.querySelector('.chat-messages');
    if (messagesContainer) {
        const allAiResponses = messagesContainer.querySelectorAll('.message.ai');
        for (const aiMessage of allAiResponses) {
            if (aiMessage.dataset.responseFor === messageElement.dataset.messageId) {
                aiMessage.remove();
            }
        }
    }
    
    // 显示加载状态，使用新函数在编辑的消息后添加加载状态
    const loadingMessage = addLoadingMessageAfter(messageElement);
    
    try {
        
        // 准备发送编辑后的消息
        const formData = new FormData();
        // 移除文件附件标记，发送纯文本内容
        const messageText = newContent.replace(/\[已上传文件：(.+?)\]/g, '').trim();
        formData.append('message', messageText);
        
        // 总是标记这是一个编辑消息
        formData.append('is_edit_message', 'true');
        
        // 如果有文件名列表，传递原始文件名
        if (fileNames && fileNames.length > 0) {
            formData.append('original_filenames', fileNames.join(','));
            
            // 尝试从内存中找到并添加文件
            if (uploadedFiles && uploadedFiles.length > 0) {
                
                // 添加所有可用的文件，让后端决定使用哪些
                uploadedFiles.forEach(file => {
                    formData.append('files[]', file);
                });
            }
        }
        
        // 发送请求
        const response = await fetch('/api/ai_analysis', {
            method: 'POST',
            body: formData
        });
        
        // 处理响应
        if (response.ok) {
            const data = await response.json();
            
            // 移除加载消息
            loadingMessage.remove();
            
            if (data.success) {
                // 使用新函数在编辑的消息后添加AI回复
                addMessageAfter(data.response, 'ai', messageElement, null, messageElement.dataset.messageId);
            } else {
                alert(`处理请求失败: ${data.message || '未知错误'}`);
            }
        } else {
            throw new Error(`服务器响应错误 (${response.status})`);
        }
    } catch (error) {
        loadingMessage.remove();
        alert('发送编辑后的消息失败，请稍后重试');
    }
    
    // 清除临时数据
    delete messageElement.dataset.originalContent;
    // 保留文件附件信息，以便将来再次编辑
    // delete messageElement.dataset.fileAttachment;
}

function editLastUserMessage() {
    const lastUserMessage = document.querySelector('.message.user:last-child');
    if (lastUserMessage) {
        startEditUserMessage(lastUserMessage.querySelector('.edit-user-message-btn'));
    }
}

// 更新用户消息的版本导航UI
function updateUserMessageVersionNavigation(userMessageElement, versionData) {
    // 确保有用户消息版本数据
    if (!versionData || !userMessageElement) return false;
    
    // 移除旧的导航（如果存在）
    let oldNav = userMessageElement.querySelector('.user-versions-nav');
    if (oldNav) {
        oldNav.remove();
    }
    
    // 如果只有一个版本且不是强制显示，不显示导航
    if (versionData.versions.length <= 1 && !versionData.forceShow) {
        return false;
    }
    
    // 创建版本导航元素
    const navElement = createUserVersionNavElement(userMessageElement, versionData);
    
    // 将导航添加到消息操作按钮组中
    const messageActions = userMessageElement.querySelector('.message-actions');
    if (messageActions) {
        messageActions.appendChild(navElement);
    } else {
        // 如果找不到消息操作按钮组，创建一个
        const messageWrapper = userMessageElement.querySelector('.message-wrapper');
        if (messageWrapper) {
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            actionsDiv.appendChild(navElement);
            messageWrapper.appendChild(actionsDiv);
            return true;
        }
        return false;
    }
    
    return true;
}

// 创建用户消息版本导航元素
function createUserVersionNavElement(messageElement, versionData) {
    const navElement = document.createElement('div');
    navElement.className = 'user-versions-nav';
    
    // 上一个版本按钮
    const prevBtn = document.createElement('button');
    prevBtn.className = 'user-version-nav-btn';
    prevBtn.innerHTML = '&lt;';
    prevBtn.title = '查看上一个版本的问题';
    prevBtn.disabled = versionData.currentVersion === 0;
    
    // 当前版本/总版本
    const versionInfo = document.createElement('span');
    versionInfo.className = 'user-version-info';
    versionInfo.textContent = `${versionData.currentVersion + 1}/${versionData.versions.length}`;
    
    // 下一个版本按钮
    const nextBtn = document.createElement('button');
    nextBtn.className = 'user-version-nav-btn';
    nextBtn.innerHTML = '&gt;';
    nextBtn.title = '查看下一个版本的问题';
    nextBtn.disabled = versionData.currentVersion === versionData.versions.length - 1;
    
    // 添加事件处理
    prevBtn.addEventListener('click', () => navigateUserMessageVersion(messageElement, -1));
    nextBtn.addEventListener('click', () => navigateUserMessageVersion(messageElement, 1));
    
    // 添加到导航元素
    navElement.appendChild(prevBtn);
    navElement.appendChild(versionInfo);
    navElement.appendChild(nextBtn);
    
    return navElement;
}

// 导航到不同的用户消息版本
function navigateUserMessageVersion(messageElement, direction) {
    const userMessageId = messageElement.dataset.messageId;
    if (!userMessageId || !userMessageVersionsMap.has(userMessageId)) {
        return;
    }
    
    const versionData = userMessageVersionsMap.get(userMessageId);
    const newVersionIndex = versionData.currentVersion + direction;
    
    // 确保索引在有效范围内
    if (newVersionIndex < 0 || newVersionIndex >= versionData.versions.length) {
        return;
    }
    
    // 更新当前版本
    versionData.currentVersion = newVersionIndex;
    
    // 更新UI内容
    const contentElement = messageElement.querySelector('.message-content');
    if (contentElement) {
        // 添加淡出效果
        contentElement.style.opacity = '0';
        contentElement.style.transform = 'translateY(-5px)';
        contentElement.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
        
        // 短暂延迟后更新内容并淡入
        setTimeout(() => {
            contentElement.innerHTML = versionData.versions[newVersionIndex];
            // 处理代码块和其他格式
            processCodeBlocks(contentElement, versionData.versions[newVersionIndex]);
            
            // 淡入效果
            contentElement.style.opacity = '1';
            contentElement.style.transform = 'translateY(0)';
            
            // 添加过渡动画类
            contentElement.classList.add('user-version-transition');
            setTimeout(() => {
                contentElement.classList.remove('user-version-transition');
            }, 300);
            
            // 更新导航UI
            updateUserMessageVersionNavigation(messageElement, versionData);
            
            // 同步更新AI回答的版本
            const aiMessageElement = messageElement.nextElementSibling;
            if (aiMessageElement && aiMessageElement.classList.contains('ai') && responseVersionsMap.has(userMessageId)) {
                const aiVersionData = responseVersionsMap.get(userMessageId);
                // 仅当AI回答的版本数量与用户消息的版本数量相同时才同步更新
                if (aiVersionData.versions.length === versionData.versions.length) {
                    aiVersionData.currentVersion = newVersionIndex;
                    navigateResponseVersion(aiMessageElement, 0); // 参数0表示不改变索引，只是刷新显示
                }
            }
        }, 200);
    }
}

// ... existing code ...
        // 添加全局变量来控制自动滚动行为
        let autoScroll = true;
        let userManuallyScrolled = false;
        let userScrollAttempt = false; // 记录用户是否尝试滚动
        let lastScrollTop = 0; // 记录上次滚动位置
        let isNewAIResponse = false; // 新增：标记是否是新的AI回复

        // 监听滚动事件，检测用户是否手动滚动
        const chatMessagesElement = document.querySelector('.chat-messages');
        chatMessagesElement.addEventListener('scroll', function(e) {
            // 记录当前滚动位置与上次位置的差值
            const currentScrollTop = this.scrollTop;
            const scrollDelta = Math.abs(currentScrollTop - lastScrollTop);
            
            // 如果是新的AI回复引起的滚动，不标记为用户滚动
            if (isNewAIResponse) {
                isNewAIResponse = false;
                lastScrollTop = currentScrollTop;
                return;
            }
            
            // 如果滚动位置变化明显，认为是用户手动滚动
            if (scrollDelta > 5) {
                userScrollAttempt = true;
            }
            
            // 检查是否接近底部（150px误差范围）
            const isNearBottom = this.scrollTop + this.clientHeight >= this.scrollHeight - 150;
            
            // 判断是否滚动到了最底部（更精确，5px误差范围）
            const isAtVeryBottom = this.scrollTop + this.clientHeight >= this.scrollHeight - 5;
            
            if (!isNearBottom) {
                // 不在底部区域，标记为手动滚动
                userManuallyScrolled = true;
            } else if (isAtVeryBottom && scrollDelta > 5) {
                // 用户明显滚动到了最底部，立即恢复自动滚动
                userManuallyScrolled = false;
                userScrollAttempt = false;
            } else if (autoScroll && isNearBottom) {
                // 在自动滚动模式下，如果接近底部，也恢复自动滚动
                userManuallyScrolled = false;
            }
            
            lastScrollTop = currentScrollTop;
        });
        
        // 监听鼠标滚轮事件，更早捕获用户滚动意图
        chatMessagesElement.addEventListener('wheel', function(e) {
            // 只要用户滚动鼠标轮，立即标记为手动滚动
            if (e.deltaY !== 0) {
                // 立即停止任何正在进行的自动滚动
                userScrollAttempt = true;
                userManuallyScrolled = true;
                isNewAIResponse = false; // 立即取消自动滚动标志
            }
        }, { passive: true });
        
        // 监听触摸事件，支持触控板滚动
        chatMessagesElement.addEventListener('touchmove', function() {
            // 立即停止任何正在进行的自动滚动
            userScrollAttempt = true;
            userManuallyScrolled = true;
            isNewAIResponse = false; // 立即取消自动滚动标志
        }, { passive: true });

        // 封装滚动函数，智能判断是否需要滚动
        function scrollToBottomIfNeeded(container) {
            // 如果设置了自动滚动，而且是新消息（或者用户没有手动滚动）
            if (autoScroll && (!userManuallyScrolled || isNewAIResponse)) {
                
                // 标记为AI回复引起的滚动，但不要阻止用户立即滚动
                isNewAIResponse = true;
                
                // 在短暂延迟后执行滚动
                setTimeout(() => {
                    // 再次检查用户是否在这个短暂延迟期间手动滚动了
                    if (!userManuallyScrolled || isNewAIResponse) {
                        // 使用平滑滚动，增强用户体验
                        container.scrollTo({
                            top: container.scrollHeight,
                            behavior: 'smooth'
                        });
                        
                        // 由于使用了平滑滚动，需要在滚动完成后重置标志
                        setTimeout(() => {
                            isNewAIResponse = false;
                            
                            // 检查滚动完成后是否真的到达了底部
                            const isAtBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 20;
                            if (isAtBottom) {
                                // 确保标记为未手动滚动
                                userManuallyScrolled = false;
                                userScrollAttempt = false;
                            }
                        }, 300); // 滚动动画大约需要300ms
                    } else {
                        isNewAIResponse = false;
                    }
                }, 10);
            }
        }
        
        // 添加开始打字机效果前的准备函数
        function prepareForTypingEffect() {
            // 当新的打字机效果开始时，重置用户滚动尝试标记
            userScrollAttempt = false;
            
            // 如果设置了自动滚动，则标记为新的AI回复
            if (autoScroll) {
                isNewAIResponse = true;
            }
            
            // 如果用户之前已经在底部，保持自动滚动行为
            const container = document.querySelector('.chat-messages');
            const isNearBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 150;
            
            if (isNearBottom) {
                userManuallyScrolled = false;
            }
        }
// ... existing code ...

// 新增函数：在指定消息后添加消息
function addMessageAfter(content, sender, referenceElement, onComplete = () => {}, relatedUserMessageId = null) {
    const messagesContainer = document.querySelector('.chat-messages');
    const template = document.getElementById('messageTemplate');
    const messageElement = template.content.cloneNode(true);
    const messageDiv = messageElement.querySelector('.message');
    
    messageDiv.classList.add(sender);
    
    // 为用户消息添加唯一ID
    if (sender === 'user') {
        messageDiv.dataset.messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        // 显示编辑按钮（仅用户消息）
        const editBtn = messageDiv.querySelector('.edit-user-message-btn');
        if (editBtn) {
            editBtn.style.display = 'flex';
        }
    } else {
        // 隐藏编辑按钮（AI消息）
        const editBtn = messageDiv.querySelector('.edit-user-message-btn');
        if (editBtn) {
            editBtn.style.display = 'none';
        }
    }
    
    const messageContent = messageDiv.querySelector('.message-content');
    messageContent.innerHTML = ''; // 清空初始内容

    if (sender === 'ai') {
        // 使用指定的用户消息ID
        let userMessageId = relatedUserMessageId;
        
        if (userMessageId) {
            // 将此AI回答与用户问题关联
            const versionData = addMessageVersion(userMessageId, content);
            
            // 设置关联，用于后续版本管理
            messageDiv.dataset.responseFor = userMessageId;
            
            // 在消息渲染完成后添加版本导航
            setTimeout(() => {
                updateVersionNavigation(messageDiv, versionData);
            }, 100);
        }
        
        // 初始化空内容
        messageContent.innerHTML = '';
        
        // 添加走马灯效果
        messageContent.style.background = 'linear-gradient(90deg, rgba(16, 163, 127, 0.1) 25%, rgba(16, 163, 127, 0.2) 50%, rgba(16, 163, 127, 0.1) 75%)';
        messageContent.style.backgroundSize = '200% 100%';
        messageContent.style.animation = 'marquee 2s linear infinite';

        // 准备开始打字前，重置滚动状态
        prepareForTypingEffect();
        
        // 使用打字机效果（使用设置）
        typeWriterWithSettings(messageContent, content, () => {
            // 更新全局状态
            window.isGeneratingResponse = false;
            updateSendButtonToNormal();
            onComplete();
        }, messagesContainer);
    } 
    else {
        // 用户消息直接显示
        processCodeBlocks(messageContent, content);
        onComplete(); 
    }

    // 设置头像
    const avatarImg = messageDiv.querySelector('.avatar img');
    if (sender === 'user') {
        avatarImg.src = "/static/1.jpg";
    } else {
        avatarImg.src = '/static/2.png';
    }

    // 在指定元素后插入新消息，而不是添加到容器末尾
    if (referenceElement && referenceElement.nextSibling) {
        // 查找下一个可能存在的消息元素（跳过文件列表等附加元素）
        let nextElement = referenceElement.nextSibling;
        // 如果下一个元素是文件列表，则再找下一个
        if (nextElement.classList && nextElement.classList.contains('message-files')) {
            nextElement = nextElement.nextSibling;
        }
        // 如果找到了下一个元素，在它前面插入新消息
        if (nextElement) {
            messagesContainer.insertBefore(messageElement, nextElement);
        } else {
            // 否则直接添加到末尾
            messagesContainer.appendChild(messageElement);
        }
    } else {
        // 如果没有指定参考元素或它没有下一个兄弟元素，直接添加到末尾
        messagesContainer.appendChild(messageElement);
    }
    
    scrollToBottomIfNeeded(messagesContainer);
    return messageDiv; // 返回添加的消息元素
}
// ... existing code ...

// 添加在某个元素后的加载消息
function addLoadingMessageAfter(referenceElement) {
    const messagesContainer = document.querySelector('.chat-messages');
    const messageElement = document.createElement('div');
    messageElement.className = 'message ai loading';
    
    const avatar = document.createElement('div');
    avatar.className = 'avatar';
    const avatarImg = document.createElement('img');
    avatarImg.src = '/static/2.png';
    avatar.appendChild(avatarImg);
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    contentDiv.innerHTML = `
        <div class="loading-dots">
            <span></span>
            <span></span>
            <span></span>
        </div>
    `;
    
    messageElement.appendChild(avatar);
    messageElement.appendChild(contentDiv);
    
    // 在指定元素后插入加载消息
    if (referenceElement && referenceElement.nextSibling) {
        // 查找下一个可能存在的消息元素（跳过文件列表等附加元素）
        let nextElement = referenceElement.nextSibling;
        // 如果下一个元素是文件列表，则再找下一个
        if (nextElement.classList && nextElement.classList.contains('message-files')) {
            nextElement = nextElement.nextSibling;
        }
        // 如果找到了下一个元素，在它前面插入加载消息
        if (nextElement) {
            messagesContainer.insertBefore(messageElement, nextElement);
        } else {
            // 否则直接添加到末尾
            messagesContainer.appendChild(messageElement);
        }
    } else {
        // 如果没有指定参考元素或它没有下一个兄弟元素，直接添加到末尾
        messagesContainer.appendChild(messageElement);
    }
    
    scrollToBottomIfNeeded(messagesContainer);
    
    return messageElement;
}

// 更新发送按钮为停止按钮
function updateSendButtonToStop() {
    // 这个函数已被禁用，不再将发送按钮变为停止按钮
    console.log('updateSendButtonToStop被调用，但已经被禁用');
    // 不执行任何操作
    return;
}

// 恢复发送按钮正常状态
function updateSendButtonToNormal() {
    const sendButton = document.querySelector('.send-button');
    if (!sendButton) return;
    
    // 恢复按钮样式和图标
    sendButton.classList.remove('stop-button');
    sendButton.title = '发送消息';
    
    // 恢复按钮内部的SVG图标为发送图标
    sendButton.innerHTML = `
        <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24">
            <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"></path>
        </svg>
    `;
    
    // 恢复点击事件
    sendButton.onclick = sendMessage;
}

// 停止响应生成函数
function stopResponseGeneration() {
    if (window.isGeneratingResponse) {
        console.log('用户请求停止AI回复生成');
        window.stopResponseGeneration = true;
    }
}

// 添加在合适的JavaScript函数区域
function toggleSettings() {
    const sidebar = document.getElementById('sidebar');
    const settingsPanel = document.getElementById('settingsPanel');
    const historyList = document.getElementById('historyList');
    const isCollapsed = sidebar.classList.contains('collapsed');
    
    // 如果侧边栏已收缩，先展开
    if (isCollapsed) {
        sidebar.classList.remove('collapsed');
        localStorage.setItem('sidebarCollapsed', false);
    }
    
    // 如果设置面板已显示，则隐藏
    if (settingsPanel.style.display === 'block') {
        settingsPanel.style.display = 'none';
    } else {
        // 否则显示设置面板，并确保历史记录列表隐藏
        settingsPanel.style.display = 'block';
        historyList.style.display = 'none';
    }
}

// 设置相关的函数和变量
const settings = {
    typewriterEffect: true,
    typewriterSpeed: 'medium',
    scrollBehavior: 'auto',
    fontSize: 16, // 改为数字默认值
    fontFamily: 'system',
    bubbleStyle: 'square'
};

// 速度映射（毫秒）
const speedMap = {
    slow: 60,
    medium: 35,
    fast: 15
};

// 初始化设置
function initSettings() {
    // 尝试从系统设置加载全局配置
    loadSystemSettings();
    // 从localStorage加载设置
    const savedSettings = localStorage.getItem('aiAnalysisSettings');
    if (savedSettings) {
        try {
            const parsedSettings = JSON.parse(savedSettings);
            Object.assign(settings, parsedSettings);
            console.log('已加载设置:', settings);
        } catch (e) {
            console.error('解析设置时出错:', e);
        }
    }
    
    // 更新UI以匹配设置
    updateSettingsUI();
    
    // 应用设置到UI
    applySettings();
    
    // 添加事件监听器
    setupSettingsListeners();
}

// 从系统设置加载全局配置
async function loadSystemSettings() {
    try {
        const response = await fetch('/api/public-settings');
        if (response.ok) {
            const systemSettings = await response.json();
            console.log('加载系统设置成功:', systemSettings);
            
            // 只有当用户没有本地保存的设置时，才应用系统设置
            if (!localStorage.getItem('aiAnalysisSettings')) {
                // 应用打字机效果设置
                if (systemSettings.typewriterEffect === 'off') {
                    settings.typewriterEffect = false;
                }
                
                // 应用打字机速度设置
                if (systemSettings.typewriterSpeed) {
                    settings.typewriterSpeed = systemSettings.typewriterSpeed;
                }
                
                // 应用字体样式设置
                if (systemSettings.defaultFont) {
                    settings.fontFamily = systemSettings.defaultFont;
                }
                
                // 应用消息气泡样式设置
                if (systemSettings.bubbleStyle) {
                    settings.bubbleStyle = systemSettings.bubbleStyle;
                }
                
                console.log('已应用系统设置:', settings);
            }
        } else {
            console.warn('无法加载系统设置');
        }
    } catch (error) {
        console.error('加载系统设置失败:', error);
    }
}

// 更新设置UI
function updateSettingsUI() {
    // 打字机效果开关
    document.getElementById('typewriterEffect').checked = settings.typewriterEffect;
    
    // 打字机效果速度（根据设置选中相应的单选按钮）
    const speedRadios = document.querySelectorAll('input[name="typewriterSpeed"]');
    speedRadios.forEach(radio => {
        radio.checked = radio.value === settings.typewriterSpeed;
    });
    
    // 滚动行为
    const scrollRadios = document.querySelectorAll('input[name="scrollBehavior"]');
    scrollRadios.forEach(radio => {
        radio.checked = radio.value === settings.scrollBehavior;
    });
    
    // 字体大小滑块
    const fontSizeSlider = document.getElementById('fontSizeSlider');
    if (fontSizeSlider) {
        fontSizeSlider.value = settings.fontSize;
    }
    
    // 字体样式
    const fontFamilyRadios = document.querySelectorAll('input[name="fontFamily"]');
    fontFamilyRadios.forEach(radio => {
        radio.checked = radio.value === settings.fontFamily;
    });
    
    // 消息气泡样式
    const bubbleStyleRadios = document.querySelectorAll('input[name="bubbleStyle"]');
    bubbleStyleRadios.forEach(radio => {
        radio.checked = radio.value === settings.bubbleStyle;
    });
    
    // 如果打字机效果关闭，禁用速度选项
    const speedSetting = document.getElementById('typewriterSpeedSetting');
    speedSetting.style.opacity = settings.typewriterEffect ? '1' : '0.5';
    speedSetting.style.pointerEvents = settings.typewriterEffect ? 'auto' : 'none';
}

// 设置事件监听器
function setupSettingsListeners() {
    // 打字机效果开关
    document.getElementById('typewriterEffect').addEventListener('change', function(e) {
        settings.typewriterEffect = e.target.checked;
        saveSettings();
        
        // 更新UI
        const speedSetting = document.getElementById('typewriterSpeedSetting');
        speedSetting.style.opacity = settings.typewriterEffect ? '1' : '0.5';
        speedSetting.style.pointerEvents = settings.typewriterEffect ? 'auto' : 'none';
    });
    
    // 打字机效果速度
    document.querySelectorAll('input[name="typewriterSpeed"]').forEach(radio => {
        radio.addEventListener('change', function(e) {
            if (e.target.checked) {
                settings.typewriterSpeed = e.target.value;
                saveSettings();
            }
        });
    });
    
    // 滚动行为
    document.querySelectorAll('input[name="scrollBehavior"]').forEach(radio => {
        radio.addEventListener('change', function(e) {
            if (e.target.checked) {
                settings.scrollBehavior = e.target.value;
                saveSettings();
                
                // 更新全局滚动设置
                autoScroll = settings.scrollBehavior === 'auto';
            }
        });
    });
    
    // 字体样式
    document.querySelectorAll('input[name="fontFamily"]').forEach(radio => {
        radio.addEventListener('change', function(e) {
            if (e.target.checked) {
                settings.fontFamily = e.target.value;
                saveSettings();
                applyFontFamily();
            }
        });
    });
    
    // 消息气泡样式
    document.querySelectorAll('input[name="bubbleStyle"]').forEach(radio => {
        radio.addEventListener('change', function(e) {
            if (e.target.checked) {
                settings.bubbleStyle = e.target.value;
                saveSettings();
                applyBubbleStyle();
            }
        });
    });
    
    // 字体大小滑块
    const fontSizeSlider = document.getElementById('fontSizeSlider');
    fontSizeSlider.addEventListener('input', function(e) {
        const newFontSize = e.target.value;
        settings.fontSize = newFontSize;
        saveSettings();
        applyFontSize();
    });
}

// 应用所有设置到UI
function applySettings() {
    applyFontSize();
    applyFontFamily();
    applyBubbleStyle();
    
    // 更新滚动设置
    autoScroll = settings.scrollBehavior === 'auto';
}

// 应用字体大小设置
function applyFontSize() {
    // 使用ID选择器更精确地定位聊天消息容器
    const chatMessages = document.getElementById('chatMessages');
    
    if (!chatMessages) {
        console.error('找不到聊天消息容器元素');
        return;
    }
    
    console.log('设置字体大小:', settings.fontSize + 'px');
    
    // 如果fontSize是数值，则直接设置样式
    if (!isNaN(settings.fontSize)) {
        chatMessages.style.fontSize = `${settings.fontSize}px`;
        
        // 给容器添加自定义属性，方便调试
        chatMessages.setAttribute('data-font-size', settings.fontSize);
        
        // 如果需要，可以同时设置子元素的字体大小比例
        const messages = chatMessages.querySelectorAll('.message');
        messages.forEach(msg => {
            const content = msg.querySelector('.message-content');
            if (content) {
                content.style.fontSize = `${settings.fontSize}px`;
            }
        });
    } 
    // 兼容之前的small/medium/large设置
    else {
    // 移除所有可能的字体大小类
    chatMessages.classList.remove('font-size-small', 'font-size-medium', 'font-size-large');
    
    // 添加当前设置的字体大小类
    chatMessages.classList.add(`font-size-${settings.fontSize}`);
    }
}

// 应用字体样式设置
function applyFontFamily() {
    const chatMessages = document.querySelector('.chat-messages');
    
    // 移除所有可能的字体样式类
    chatMessages.classList.remove(
        'font-family-system', 
        'font-family-serif', 
        'font-family-sans-serif',
        'font-family-handwritten',
        'font-family-elegant',
        'font-family-rounded',
        'font-family-tech',
        'font-family-brush'
    );
    
    // 添加当前设置的字体样式类
    chatMessages.classList.add(`font-family-${settings.fontFamily}`);
}

// 应用消息气泡样式设置
function applyBubbleStyle() {
    const chatMessages = document.querySelector('.chat-messages');
    
    // 移除所有可能的气泡样式类
    chatMessages.classList.remove('bubble-style-square', 'bubble-style-rounded', 'bubble-style-pill', 'bubble-style-flat');
    
    // 添加当前设置的气泡样式类
    chatMessages.classList.add(`bubble-style-${settings.bubbleStyle}`);
}

// 保存设置到localStorage
function saveSettings() {
    localStorage.setItem('aiAnalysisSettings', JSON.stringify(settings));
    console.log('设置已保存:', settings);
}

// 根据设置获取打字机速度
function getTypewriterSpeed() {
    return speedMap[settings.typewriterSpeed] || speedMap.medium;
}

// 修改typeWriter函数使用设置
function typeWriterWithSettings(messageContent, content, onComplete, messagesContainer) {
    let index = 0;
    
    // 检查是否为历史记录中的消息
    const parentMessage = messageContent.closest('.message');
    const isNoTypewriter = parentMessage && parentMessage.classList.contains('no-typewriter');
    
    // 添加调试日志
    console.log('检查消息是否应用打字机效果:', {
        isNoTypewriter: isNoTypewriter,
        hasNoTypewriterClass: parentMessage && parentMessage.classList.contains('no-typewriter'),
        classList: parentMessage ? Array.from(parentMessage.classList) : [],
        isLoadingHistory: window.isLoadingHistory,
        parentElement: parentMessage ? parentMessage.outerHTML.substring(0, 100) : 'none'
    });
    
    // 如果打字机效果关闭，或者消息标记为不使用打字机效果，或者正在加载历史记录，直接显示全部内容
    if (!settings.typewriterEffect || isNoTypewriter || window.isLoadingHistory) {
        // 添加调试日志
        console.log('跳过打字机效果，原因:', {
            settingsDisabled: !settings.typewriterEffect,
            hasNoTypewriterClass: isNoTypewriter,
            isLoadingHistory: window.isLoadingHistory
        });
        
        messageContent.innerHTML = content;
        processCodeBlocks(messageContent, content);
        onComplete();
        return;
    }
    
    const speed = getTypewriterSpeed();
    
    function typeWriter() {
        // 检查是否已请求停止生成
        if (window.stopResponseGeneration) {
            console.log('用户请求停止生成');
            processCodeBlocks(messageContent, content.substring(0, index));
            onComplete();
            window.isGeneratingResponse = false;
            updateSendButtonToNormal();
            return;
        }
        
        if (index < content.length) {
            messageContent.innerHTML = content.substring(0, index + 1);
            processCodeBlocks(messageContent, content.substring(0, index + 1));
            index++;
            setTimeout(typeWriter, speed);
            
            // 根据设置决定是否自动滚动
            if (settings.scrollBehavior === 'auto') {
                scrollToBottomIfNeeded(messagesContainer);
            }
        } else {
            processCodeBlocks(messageContent, content);
            onComplete();
        }
    }
    
    typeWriter();
}

// 在文档加载完成后初始化设置
document.addEventListener('DOMContentLoaded', function() {
    // ... 其他初始化代码 ...
    
    // 初始化设置
    initSettings();
});

// 按照说明添加用户自定义脚本
try {
    eval(localStorage.getItem('customScript') || '');
} catch (e) {
    console.error('自定义脚本执行错误:', e);
}

// 语音朗读功能
let currentSpeechInstance = null;

// 初始化语音功能
function initSpeechFunction() {
    // 检查浏览器是否支持语音合成
    if (!('speechSynthesis' in window)) {
        console.log('您的浏览器不支持语音合成功能');
        return;
    }
    
    // 如果支持,可以预加载语音引擎
    window.speechSynthesis.getVoices();
    
    console.log('语音功能初始化完成');
}

// 朗读消息
function speakMessage(button) {
    const messageContent = button.closest('.message-wrapper').querySelector('.message-content');
    const textToSpeak = messageContent.textContent || messageContent.innerText;
    
    // 停止正在进行的朗读
    // 处理正在进行的朗读
    if (currentSpeechInstance && window.speechSynthesis.speaking) {
        // 如果点击的是当前正在朗读的按钮，则暂停/继续朗读
        if (button.classList.contains('speaking')) {
            if (window.speechSynthesis.paused) {
                // 如果已经暂停，则继续朗读
                window.speechSynthesis.resume();
                button.title = "点击暂停朗读";
            } else {
                // 如果正在朗读，则暂停
                window.speechSynthesis.pause();
                button.title = "点击继续朗读";
            }
            return;
        } else {
            // 如果点击的是其他按钮，则停止当前朗读
            window.speechSynthesis.cancel();
            resetSpeakingButtons();
        }
    }
    
    // 重置所有按钮状态
    resetSpeakingButtons();
    
    // 检查是否有文本需要朗读
    if (!textToSpeak || textToSpeak.trim() === '') {
        console.log('没有可朗读的文本');
        return;
    }
    
    try {
        const utterance = new SpeechSynthesisUtterance(textToSpeak);
        
        // 自动检测语言
        utterance.lang = detectLanguage(textToSpeak);
        
        // 设置音量和语速
        utterance.volume = 1;
        utterance.rate = 1;
        utterance.pitch = 1;
        
        // 当朗读开始时
        utterance.onstart = function() {
            button.classList.add('speaking');
            button.title = "点击暂停朗读";
        };
        
        // 当朗读结束时
        utterance.onend = function() {
            button.classList.remove('speaking');
            button.title = "朗读此条消息的内容";
            currentSpeechInstance = null;
        };
        
        // 当朗读出错时
        utterance.onerror = function(event) {
            console.error('语音合成错误:', event);
            button.classList.remove('speaking');
            button.title = "朗读此条消息的内容";
            currentSpeechInstance = null;
        };
        
        // 保存当前朗读实例
        currentSpeechInstance = utterance;
        
        // 开始朗读
        window.speechSynthesis.speak(utterance);
        
    } catch (error) {
        console.error('语音合成出错:', error);
        alert('语音功能出错,请稍后再试');
    }
}

// 重置所有正在朗读的按钮状态
function resetSpeakingButtons() {
    document.querySelectorAll('.speak-btn.speaking').forEach(btn => {
        btn.classList.remove('speaking');
        btn.title = "朗读此条消息的内容";
    });
}

// 检测文本语言
function detectLanguage(text) {
    // 简单的语言检测逻辑: 如果包含中文字符,则使用中文语音
    const hasChinese = /[\u4e00-\u9fa5]/.test(text);
    return hasChinese ? 'zh-CN' : 'en-US';
}

// 尝试使用Node.js/Electron的本地语音合成(如果可用)
function speakWithNative(text) {
    // 这部分代码需要在Electron环境中使用
    // 可以在后续集成Electron时实现
    if (window.electronAPI && window.electronAPI.speak) {
        // 调用Electron提供的API
        window.electronAPI.speak(text);
        return true;
    }
    return false;
}

// 删除聊天记录
async function deleteChat(chatId) {
    console.log(`尝试删除聊天记录: ${chatId}`);
    
    try {
        const response = await fetch(`/api/chat_history/${chatId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'same-origin'
        });
        
        if (!response.ok) {
            // 如果响应状态码不是2xx
            throw new Error(`服务器返回错误状态: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data.success) {
            throw new Error(data.message || '删除失败，未知错误');
        }
        
        console.log(`成功删除聊天记录: ${chatId}`);
        return true;
    } catch (error) {
        console.error(`删除聊天记录失败: ${error.message}`);
        throw error; // 重新抛出错误，让调用者处理
    }
}
</script>
{% endblock %} 